{"version":3,"file":"static/js/917.c06122d0.chunk.js","mappings":"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","sources":["external/shared.js","external/TdPlayground.js","workers/validationWorker.js","util.js","../webpack/bootstrap","../webpack/runtime/chunk loaded","../webpack/runtime/compat get default export","../webpack/runtime/define property getters","../webpack/runtime/ensure chunk","../webpack/runtime/get javascript chunk filename","../webpack/runtime/get mini-css chunk filename","../webpack/runtime/global","../webpack/runtime/hasOwnProperty shorthand","../webpack/runtime/make namespace object","../webpack/runtime/publicPath","../webpack/runtime/importScripts chunk loading","../webpack/runtime/startup chunk dependencies","../webpack/startup"],"sourcesContent":[" /**\n  * This file contains functions, which are required by the core package as\n  * well as by the assertions package\n  */\n\n// A special JSON validator that is used only to check whether the given object has duplicate keys.\n// The standard library doesn't detect duplicate keys and overwrites the first one with the second one.\n// TODO: replace with jsonlint ??\nimport jsonValidator from 'json-dup-key-validator';\n\n\n// This is used to validate if the multi language JSON keys are valid according to the BCP47 spec\nconst bcp47pattern = /^(?:(en-GB-oed|i-ami|i-bnn|i-default|i-enochian|i-hak|i-klingon|i-lux|i-mingo|i-navajo|i-pwn|i-tao|i-tay|i-tsu|sgn-BE-FR|sgn-BE-NL|sgn-CH-DE)|(art-lojban|cel-gaulish|no-bok|no-nyn|zh-guoyu|zh-hakka|zh-min|zh-min-nan|zh-xiang))$|^((?:[a-z]{2,3}(?:(?:-[a-z]{3}){1,3})?)|[a-z]{4}|[a-z]{5,8})(?:-([a-z]{4}))?(?:-([a-z]{2}|\\d{3}))?((?:-(?:[\\da-z]{5,8}|\\d[\\da-z]{3}))*)?((?:-[\\da-wy-z](?:-[\\da-z]{2,8})+)*)?(-x(?:-[\\da-z]{1,8})+)?$|^(x(?:-[\\da-z]{1,8})+)$/i // eslint-disable-line max-len\n\n\nexport {\n    checkPropUniqueness,\n    checkSecurity,\n    checkMultiLangConsistency,\n    checkLinksRelTypeCount,\n    checkUriSecurity,\n    checkTmOptionalPointer\n}\n\n/**\n * This function returns part of the object given in param with the value found when resolving the path. Similar to JSON Pointers.\n * In case no path is found, the param defaultValue is echoed back\n * Taken from\n * https://stackoverflow.com/questions/6491463/accessing-nested-javascript-objects-and-arrays-by-string-path/6491621#6491621\n * @param {object} object\n * @param {string} path\n * @param {any} defaultValue\n * @return {object}\n **/\nconst resolvePath = (object, path, defaultValue) => path\n    //eslint-disable-next-line\n    .split(/[\\.\\[\\]\\'\\\"]/)\n    .filter(p => p)\n    .reduce((o, p) => o ? o[p] : defaultValue, object)\n\n// -------------------------------------------------- checkPropUniqueness\n\n/**\n *  Checking whether in one interaction pattern there are duplicate names, e.g. two properties called temp\n *  However, if there are no properties then it is not-impl\n *\n * @param {string} tdString The Td under test as string\n */\nfunction checkPropUniqueness(tdString) {\n\n    const results = []\n\n    // jsonvalidator throws an error if there are duplicate names in the interaction level\n    try {\n        jsonValidator.parse(tdString, false)\n\n        const td = JSON.parse(tdString)\n\n        // no problem in interaction level\n        //eslint-disable-next-line\n        // let tdInteractions = [] // not used\n\n        // checking whether there are properties at all, if not uniqueness is not impl\n        if (td.hasOwnProperty(\"properties\")) {\n            // tdInteractions = tdInteractions.concat(Object.keys(td.properties)) // not used\n            // then we can add unique properties pass\n            results.push({\n                \"ID\": \"td-properties_uniqueness\",\n                \"Status\": \"pass\",\n                \"Comment\": \"\"\n            })\n        } else {\n            // then we add unique properties as not impl\n            results.push({\n                \"ID\": \"td-properties_uniqueness\",\n                \"Status\": \"not-impl\",\n                \"Comment\": \"no properties\"\n            })\n        }\n\n        // similar to just before, checking whether there are actions at all, if not uniqueness is not impl\n        if (td.hasOwnProperty(\"actions\")) {\n            // tdInteractions = tdInteractions.concat(Object.keys(td.actions)) // not used\n            results.push({\n                \"ID\": \"td-actions_uniqueness\",\n                \"Status\": \"pass\",\n                \"Comment\": \"\"\n            })\n        } else {\n            // then we add unique actions as not impl\n            results.push({\n                \"ID\": \"td-actions_uniqueness\",\n                \"Status\": \"not-impl\",\n                \"Comment\": \"no actions\"\n            })\n        }\n\n        // similar to just before, checking whether there are events at all, if not uniqueness is not impl\n        if (td.hasOwnProperty(\"events\")) {\n            // tdInteractions = tdInteractions.concat(Object.keys(td.events)) // not used\n            results.push({\n                \"ID\": \"td-events_uniqueness\",\n                \"Status\": \"pass\",\n                \"Comment\": \"\"\n            })\n        } else {\n            // then we add unique events as not impl\n            results.push({\n                \"ID\": \"td-events_uniqueness\",\n                \"Status\": \"not-impl\",\n                \"Comment\": \"no events\"\n            })\n        }\n\n        return results\n\n    } catch (error) {\n        // there is a duplicate somewhere\n\n        // convert it into string to be able to process it\n        // error is of form = Error: Syntax error: duplicated keys \"overheating\" near ting\": {\n        const errorString = error.toString()\n        // to get the name, we need to remove the quotes around it\n        const startQuote = errorString.indexOf('\"')\n        // slice to remove the part before the quote\n        const restString = errorString.slice(startQuote + 1)\n        // find where the interaction name ends\n        const endQuote = restString.indexOf('\"')\n        // finally get the interaction name\n        const interactionName = restString.slice(0, endQuote)\n\n        // trying to find where this interaction is and put results accordingly\n        const td = JSON.parse(tdString)\n\n        if (td.hasOwnProperty(\"properties\")) {\n            const tdProperties = td.properties\n            if (tdProperties.hasOwnProperty(interactionName)) {\n                // duplicate was at properties but that fails the td-unique identifiers as well\n                results.push({\n                    \"ID\": \"td-properties_uniqueness\",\n                    \"Status\": \"fail\",\n                    \"Comment\": \"duplicate property names\"\n                })\n                // since JSON.parse removes duplicates, we replace the duplicate name with duplicateName\n                tdString = tdString.replace(interactionName, \"duplicateName\")\n\n            } else {\n                // there is duplicate but not here, so pass\n                results.push({\n                    \"ID\": \"td-properties_uniqueness\",\n                    \"Status\": \"pass\",\n                    \"Comment\": \"\"\n                })\n            }\n        } else {\n            results.push({\n                \"ID\": \"td-properties_uniqueness\",\n                \"Status\": \"not-impl\",\n                \"Comment\": \"no properties\"\n            })\n        }\n\n        if (td.hasOwnProperty(\"actions\")) {\n            const tdActions = td.actions\n            if (tdActions.hasOwnProperty(interactionName)) {\n                // duplicate was at actions but that fails the td-unique identifiers as well\n                results.push({\n                    \"ID\": \"td-actions_uniqueness\",\n                    \"Status\": \"fail\",\n                    \"Comment\": \"duplicate action names\"\n                })\n                // since JSON.parse removes duplicates, we replace the duplicate name with duplicateName\n                tdString = tdString.replace(interactionName, \"duplicateName\")\n            } else {\n                results.push({\n                    \"ID\": \"td-actions_uniqueness\",\n                    \"Status\": \"pass\",\n                    \"Comment\": \"\"\n                })\n            }\n        } else {\n            results.push({\n                \"ID\": \"td-actions_uniqueness\",\n                \"Status\": \"not-impl\",\n                \"Comment\": \"no actions\"\n            })\n        }\n\n        if (td.hasOwnProperty(\"events\")) {\n            const tdEvents = td.events\n            if (tdEvents.hasOwnProperty(interactionName)) {\n                // duplicate was at events but that fails the td-unique identifiers as well\n                results.push({\n                    \"ID\": \"td-events_uniqueness\",\n                    \"Status\": \"fail\",\n                    \"Comment\": \"duplicate event names\"\n                })\n                // since JSON.parse removes duplicates, we replace the duplicate name with duplicateName\n                tdString = tdString.replace(interactionName, \"duplicateName\")\n            } else {\n                results.push({\n                    \"ID\": \"td-events_uniqueness\",\n                    \"Status\": \"pass\",\n                    \"Comment\": \"\"\n                })\n            }\n        } else {\n            results.push({\n                \"ID\": \"td-events_uniqueness\",\n                \"Status\": \"not-impl\",\n                \"Comment\": \"no events\"\n            })\n        }\n\n        return results\n    }\n}\n\n\n// -------------------------------------------------- checkSecurity\n\n/**\n * check if used Security definitions are properly defined previously\n * @param {object} td The TD to do assertion tests\n */\nfunction checkSecurity(td) {\n\n    const results = []\n    if (td.hasOwnProperty(\"securityDefinitions\")) {\n        const securityDefinitionsObject = td.securityDefinitions\n        const securityDefinitions = Object.keys(securityDefinitionsObject)\n\n\n        const rootSecurity = td.security\n\n        if (securityContains(securityDefinitions, rootSecurity)) {\n            // all good\n        } else {\n            results.push({\n                \"ID\": \"td-security-scheme-name\",\n                \"Status\": \"fail\",\n                \"Comment\": \"used a non defined security scheme in root level\"\n            })\n            return results\n        }\n\n        if (td.hasOwnProperty(\"properties\")) {\n            // checking security in property level\n            let tdProperties = Object.keys(td.properties)\n            for (let i = 0; i < tdProperties.length; i++) {\n                const curPropertyName = tdProperties[i]\n                const curProperty = td.properties[curPropertyName]\n\n                // checking security in forms level\n                const curForms = curProperty.forms\n                for (let j = 0; j < curForms.length; j++) {\n                    const curForm = curForms[j]\n                    if (curForm.hasOwnProperty(\"security\")) {\n                        const curSecurity = curForm.security\n                        if (securityContains(securityDefinitions, curSecurity)) {\n                            // all good\n                        } else {\n                            results.push({\n                                \"ID\": \"td-security-scheme-name\",\n                                \"Status\": \"fail\",\n                                \"Comment\": \"used a non defined security scheme in a property form\"\n                            })\n                            return results\n                        }\n                    }\n                }\n            }\n        }\n\n        if (td.hasOwnProperty(\"actions\")) {\n            // checking security in action level\n            let tdActions = Object.keys(td.actions)\n            for (let i = 0; i < tdActions.length; i++) {\n                const curActionName = tdActions[i]\n                const curAction = td.actions[curActionName]\n\n                // checking security in forms level\n                const curForms = curAction.forms\n                for (let j = 0; j < curForms.length; j++) {\n                    const curForm = curForms[j]\n                    if (curForm.hasOwnProperty(\"security\")) {\n                        const curSecurity = curForm.security\n                        if (securityContains(securityDefinitions, curSecurity)) {\n                            // all good\n                        } else {\n                            results.push({\n                                \"ID\": \"td-security-scheme-name\",\n                                \"Status\": \"fail\",\n                                \"Comment\": \"used a non defined security scheme in an action form\"\n                            })\n                            return results\n                        }\n                    }\n                }\n\n            }\n        }\n\n        if (td.hasOwnProperty(\"events\")) {\n            // checking security in event level\n            let tdEvents = Object.keys(td.events)\n            for (let i = 0; i < tdEvents.length; i++) {\n                const curEventName = tdEvents[i]\n                const curEvent = td.events[curEventName]\n\n                // checking security in forms level\n                const curForms = curEvent.forms\n                for (let j = 0; j < curForms.length; j++) {\n                    const curForm = curForms[j]\n                    if (curForm.hasOwnProperty(\"security\")) {\n                        const curSecurity = curForm.security\n                        if (securityContains(securityDefinitions, curSecurity)) {\n                            // all good\n                        } else {\n                            results.push({\n                                \"ID\": \"td-security-scheme-name\",\n                                \"Status\": \"fail\",\n                                \"Comment\": \"used a non defined security scheme in an event form\"\n                            })\n                            return results\n                        }\n                    }\n                }\n\n            }\n        }\n\n        // no security used non defined scheme, passed test\n        results.push({\n            \"ID\": \"td-security-scheme-name\",\n            \"Status\": \"pass\"\n        })\n        return results\n\n    }\n    return results\n}\n\n/**\n * subfunction of checkSecurity\n * security anywhere could be a string or array. Convert string to array\n *\n * @param {*} parent\n * @param {string|Array<string>} child\n */\nfunction securityContains(parent, child) {\n\n    if (typeof child === \"string\") {\n        child = [child]\n    }\n    return child.every(elem => parent.indexOf(elem) > -1)\n}\n\n\n// -------------------------------------------------- checkMultiLangConsistency\n\n/**\n *  this checks whether all titles and descriptions have the same language fields\n *  so the object keys of a titles and of a descriptions should be the same already,\n *  then everywhere else they should also be the same\n *\n *  first collect them all, and then compare them\n *\n * @param {object} td The TD to do assertion tests\n */\nfunction checkMultiLangConsistency(td) {\n\n    const results = []\n    const multiLang = [] // an array of arrays where each small array has the multilang keys\n    const isTdTitlesDescriptions = [] // an array of boolean values to check td-titles-descriptions assertion\n\n    // checking root\n    if (td.hasOwnProperty(\"titles\")) {\n        const rootTitlesObject = td.titles\n        const rootTitles = Object.keys(rootTitlesObject)\n        multiLang.push(rootTitles)\n        // checking for td-titles-descriptions\n        //eslint-disable-next-line\n        isTdTitlesDescriptions.push({[\"root_title\"]: isStringObjectKeyValue(td.title, rootTitlesObject)})\n    }\n\n    if (td.hasOwnProperty(\"descriptions\")) {\n        const rootDescriptionsObject = td.descriptions\n        const rootDescriptions = Object.keys(rootDescriptionsObject)\n        multiLang.push(rootDescriptions)\n        // check whether description exists in descriptions\n        if (td.hasOwnProperty(\"description\")) {\n            //eslint-disable-next-line\n            isTdTitlesDescriptions.push({[\"root_description\"]: isStringObjectKeyValue(td.description, rootDescriptionsObject)})\n        }\n    }\n\n    // checking inside each interaction\n    if (td.hasOwnProperty(\"properties\")) {\n        // checking security in property level\n        let tdProperties = Object.keys(td.properties)\n        for (let i = 0; i < tdProperties.length; i++) {\n            const curPropertyName = tdProperties[i]\n            const curProperty = td.properties[curPropertyName]\n\n            if (curProperty.hasOwnProperty(\"titles\")) {\n                const titlesKeys = Object.keys(curProperty.titles)\n                multiLang.push(titlesKeys)\n                // checking if title exists in titles\n                if (curProperty.hasOwnProperty(\"title\")) {\n                    isTdTitlesDescriptions.push({\n                        [\"property_\"+curPropertyName + \"_title\"]: isStringObjectKeyValue(curProperty.title, curProperty.titles)\n                    })\n                }\n            }\n\n            if (curProperty.hasOwnProperty(\"descriptions\")) {\n                const descriptionsKeys = Object.keys(curProperty.descriptions)\n                multiLang.push(descriptionsKeys)\n                // checking if description exists in descriptions\n                if (curProperty.hasOwnProperty(\"description\")) {\n                    isTdTitlesDescriptions.push({\n                    [\"property_\" + curPropertyName + \"_desc\"]: isStringObjectKeyValue(curProperty.description,curProperty.descriptions)\n                    })\n                }\n            }\n        }\n    }\n\n    if (td.hasOwnProperty(\"actions\")) {\n        // checking security in action level\n        let tdActions = Object.keys(td.actions)\n        for (let i = 0; i < tdActions.length; i++) {\n            const curActionName = tdActions[i]\n            const curAction = td.actions[curActionName]\n\n            if (curAction.hasOwnProperty(\"titles\")) {\n                const titlesKeys = Object.keys(curAction.titles)\n                multiLang.push(titlesKeys)\n                // checking if title exists in titles\n                if (curAction.hasOwnProperty(\"title\")) {\n                    isTdTitlesDescriptions.push({\n                        [\"action_\" + curActionName + \"_title\"]: isStringObjectKeyValue(curAction.title, curAction.titles)\n                    })\n                }\n            }\n\n            if (curAction.hasOwnProperty(\"descriptions\")) {\n                const descriptionsKeys = Object.keys(curAction.descriptions)\n                multiLang.push(descriptionsKeys)\n                // checking if description exists in descriptions\n                if (curAction.hasOwnProperty(\"description\")) {\n                    isTdTitlesDescriptions.push({\n                         [\"action_\" + curActionName + \"_desc\"]: isStringObjectKeyValue(curAction.description, curAction.descriptions)\n                    })\n                }\n            }\n\n        }\n    }\n\n    if (td.hasOwnProperty(\"events\")) {\n        // checking security in event level\n        let tdEvents = Object.keys(td.events)\n        for (let i = 0; i < tdEvents.length; i++) {\n            const curEventName = tdEvents[i]\n            const curEvent = td.events[curEventName]\n\n            if (curEvent.hasOwnProperty(\"titles\")) {\n                const titlesKeys = Object.keys(curEvent.titles)\n                multiLang.push(titlesKeys)\n                // checking if title exists in titles\n                if (curEvent.hasOwnProperty(\"title\")) {\n                    isTdTitlesDescriptions.push({\n                        [\"event_\" + curEventName + \"_title\"]: isStringObjectKeyValue(curEvent.title, curEvent.titles)\n                    })\n                }\n            }\n\n            if (curEvent.hasOwnProperty(\"descriptions\")) {\n                const descriptionsKeys = Object.keys(curEvent.descriptions)\n                multiLang.push(descriptionsKeys)\n                // checking if description exists in descriptions\n                if (curEvent.hasOwnProperty(\"description\")) {\n                    isTdTitlesDescriptions.push({\n                        [\"event_\" + curEventName + \"_desc\"]: isStringObjectKeyValue(curEvent.description, curEvent.descriptions)\n                    })\n                }\n            }\n\n        }\n    }\n    if(arrayArraysItemsEqual(multiLang)){\n        results.push({\n            \"ID\": \"td-multi-languages-consistent\",\n            \"Status\": \"pass\"\n        })\n    } else {\n        results.push({\n            \"ID\": \"td-multi-languages-consistent\",\n            \"Status\": \"fail\",\n            \"Comment\": \"not all multilang objects have same language tags\"\n        })\n    }\n\n    const flatArray = [] // this is multiLang but flat, so just a single array.\n    // This way we can have scan the whole thing at once and then find the element that is not bcp47\n\n    for (let index = 0; index < multiLang.length; index++) {\n        let arrayElement = multiLang[index]\n        arrayElement=JSON.parse(arrayElement)\n        for (let e = 0; e < arrayElement.length; e++) {\n            const stringElement = arrayElement[e]\n            flatArray.push(stringElement)\n        }\n    }\n    const isBCP47 = checkBCP47array(flatArray)\n    if(isBCP47 === \"ok\"){\n        results.push({\n            \"ID\": \"td-multilanguage-language-tag\",\n            \"Status\": \"pass\"\n        })\n    } else {\n        results.push({\n            \"ID\": \"td-multilanguage-language-tag\",\n            \"Status\": \"fail\",\n            \"Comment\":isBCP47+\" is not a BCP47 tag\"\n        })\n    }\n\n    // // checking td-context-default-language-direction-script assertion\n    // results.push({\n    //     \"ID\": \"td-context-default-language-direction-script\",\n    //     \"Status\": checkAzeri(flatArray)\n    // })\n\n    // checking td-titles-descriptions assertion\n    // if there are no multilang, then it is not impl\n    if(isTdTitlesDescriptions.length === 0){\n        results.push({\n            \"ID\": \"td-titles-descriptions\",\n            \"Status\": \"not-impl\",\n            \"Comment\": \"no multilang objects in the td\"\n        })\n        return results\n    }\n\n    // if at some point there was a false result, it is a fail\n    for (let index = 0; index < isTdTitlesDescriptions.length; index++) {\n        const element = isTdTitlesDescriptions[index]\n        const elementName = Object.keys(element)\n\n        if(element[elementName]){\n            // do nothing it is correct\n        } else {\n            results.push({\n                \"ID\": \"td-titles-descriptions\",\n                \"Status\": \"fail\",\n                \"Comment\": elementName+\" is not on the multilang object at the same level\"\n            })\n            return results\n        }\n    }\n    // there was no problem, so just put pass\n    results.push({\n        \"ID\": \"td-titles-descriptions\",\n        \"Status\": \"pass\"\n    })\n\n    // ? nothing after this, there is return above\n    return results\n}\n\n/**\n * subfunction of checkMultiLangConsistency\n * checks if an array that contains only arrays as items is composed of same items\n *\n * @param {Array<object>} myArray The array to check\n */\nfunction arrayArraysItemsEqual(myArray) {\n    if(myArray.length === 0) return true\n    // first stringify each array item\n    for (let i = myArray.length; i--;) {\n        myArray[i] = JSON.stringify(myArray[i])\n    }\n\n    for (let i = myArray.length; i--;) {\n        if (i === 0) {\n            return true\n        }\n        if (myArray[i] !== myArray[i - 1]){\n            return false\n        }\n    }\n}\n\n/**\n * subfunction of checkMultiLangConsistency\n * checks whether the items of an array, which must be strings, are valid language tags\n *\n * @param {Array<string>} myArray The array, which items are to be checked\n */\nfunction checkBCP47array(myArray){\n    // return tag name if one is not valid during the check\n\n    for (let index = 0; index < myArray.length; index++) {\n        const element = myArray[index]\n        if (bcp47pattern.test(element)) {\n            // keep going\n        } else {\n            return element\n        }\n    }\n\n    // return true if reached the end\n    return \"ok\"\n}\n\n/**\n * subfunction of checkMultiLangConsistency\n * checks whether a given string exist as the value of key in an object\n *\n * @param {string} searchedString\n * @param {object} searchedObject\n */\nfunction isStringObjectKeyValue(searchedString, searchedObject){\n    const objKeys = Object.keys(searchedObject)\n    if(objKeys.length === 0) return false // if the object is empty, then the string cannot exist here\n    for (let index = 0; index < objKeys.length; index++) {\n        const element = objKeys[index]\n        if (searchedObject[element] === searchedString) {\n            return true // found where the string is in the object\n        } else {\n            // nothing keep going, maybe in another key\n        }\n    }\n    return false\n}\n\n\n/**\n * subfunction of checkMultiLangConsistency\n * checks whether an azeri language tag also specifies the version (Latn or Arab).\n * basically if the language is called \"az\", it is invalid, if it is az-Latn or az-Arab it is valid.\n *\n * @param {Array<string>} myMultiLangArray The language array to check\n */\n// function checkAzeri(myMultiLangArray){\n//     for (let index = 0; index < myMultiLangArray.length; index++) {\n//         const element = myMultiLangArray[index]\n//         if (element ===\"az\"){\n//             return \"fail\"\n//         } else if ((element === \"az-Latn\") || (element === \"az-Arab\")){\n//             return \"pass\"\n//         }\n//     }\n//     // no azeri, so it is not implemented\n//     return \"not-impl\"\n// }\n\n// --------------------------------------------------\n\n// -------------------------------------------------- checkLinksRelTypeCount\n\n/**\n *  this checks whether rel:type appears only once in the links array\n *\n * @param {object} td The TD to do assertion tests\n */\nfunction checkLinksRelTypeCount(td){\n\n    const results = []\n\n    if (td.hasOwnProperty(\"links\")){\n        // links exist, check if there is rel type\n        let typeCount = 0\n        for (let i = 0; i < td.links.length; i++) {\n            const element = td.links[i]\n            if(element.hasOwnProperty(\"rel\")){\n                if (element.rel === \"type\"){\n                    typeCount++\n                }\n            }\n        }\n        if (typeCount === 0){\n            results.push({\n                \"ID\": \"tm-rel-type-maximum\",\n                \"Status\": \"not-impl\",\n                \"Comment\": \"no rel:type in any link\"\n            })\n        } else if (typeCount === 1){\n            results.push({\n                \"ID\": \"tm-rel-type-maximum\",\n                \"Status\": \"pass\",\n                \"Comment\": \"\"\n            })\n        } else {\n            results.push({\n                \"ID\": \"tm-rel-type-maximum\",\n                \"Status\": \"fail\",\n                \"Comment\": \"too many rel:type in links array\"\n            })\n        }\n    } else {\n        results.push({\n            \"ID\": \"tm-rel-type-maximum\",\n            \"Status\": \"not-impl\",\n            \"Comment\": \"no links array in the td\"\n        })\n    }\n    return results\n}\n\n/**\n * When you have apikey security with the key in uri, you put the name of the urivariable in the name field in\n * securityDefinitions. Ideally, that name appears in href as a uriVariable. See uriSecurity example\n * td-security-in-uri-variable: The URIs provided in interactions where a security scheme using uri as the value for\n * in MUST be a URI template including the defined variable.\n * Additionally, this also checks that the uriVariable used in the security does not conflict with ones for the TD\n * td-security-uri-variables-distinct: The names of URI variables declared in a SecurityScheme MUST be distinct from\n * all other URI variables declared in the TD.\n * @param {object} td The TD to do assertion tests\n */\nfunction checkUriSecurity(td) {\n\n    const results = []\n    if (td.hasOwnProperty(\"securityDefinitions\")) {\n        const securityDefinitionsObject = td.securityDefinitions\n        const securityDefinitionsNames = Object.keys(securityDefinitionsObject)\n\n        const securityUriVariables = [];\n        for (let index = 0; index < securityDefinitionsNames.length; index++) {\n            const curSecurityDefinition = securityDefinitionsObject[securityDefinitionsNames[index]];\n            if (curSecurityDefinition.scheme === \"apikey\"){\n                if (curSecurityDefinition.hasOwnProperty(\"in\")){\n                    if (curSecurityDefinition.in === \"uri\"){\n                        if (curSecurityDefinition.hasOwnProperty(\"name\")){\n                            securityUriVariables.push(curSecurityDefinition.name)\n                        }\n                    }\n                }\n            }\n        }\n\n        if (securityUriVariables.length === 0){ // we could not find any\n            results.push({\n                \"ID\": \"td-security-in-uri-variable\",\n                \"Status\": \"not-impl\",\n                \"Comment\": \"no use of name in a uri apikey scheme\"\n            })\n            results.push({\n                \"ID\": \"td-security-uri-variables-distinct\",\n                \"Status\": \"not-impl\",\n                \"Comment\": \"no use of name in a uri apikey scheme\"\n            })\n            return results\n        } else {\n            let uriVariablesResult = \"not-impl\"\n            let uriVariablesDistinctResult = \"not-impl\"\n            let rootUriVariables = [];\n            if (td.hasOwnProperty(\"uriVariables\")) {\n                rootUriVariables = Object.keys(td.uriVariables)\n            }\n            if (td.hasOwnProperty(\"properties\")) {\n                // checking security in property level\n                let tdProperties = Object.keys(td.properties)\n                for (let i = 0; i < tdProperties.length; i++) {\n                    const curPropertyName = tdProperties[i]\n                    const curProperty = td.properties[curPropertyName]\n                    // checking href with uriVariable in forms level\n                    const curForms = curProperty.forms\n                    for (let j = 0; j < curForms.length; j++) {\n                        const curForm = curForms[j]\n                        if (curForm.hasOwnProperty(\"href\")){\n                            const curHref = curForm.href\n                            // bottom thing is taken from https://stackoverflow.com/a/5582621/3806426\n                            if (securityUriVariables.some(v => curHref.includes(v))) {\n                                // There's at least one\n                                if(uriVariablesResult !== \"fail\"){\n                                    uriVariablesResult = \"pass\"\n                                }\n                            }\n                        }\n                    }\n                    // part for the check of td-security-uri-variables-distinct\n                    if (curProperty.hasOwnProperty(\"uriVariables\")){\n                        let curPropertyUriVariables = Object.keys(curProperty.uriVariables)\n                        curPropertyUriVariables.push(...rootUriVariables)\n                        if (curPropertyUriVariables.length>0){ // there are urivariables somewhere at least\n                            // below is from https://stackoverflow.com/a/1885569/3806426\n                            const filteredArray = curPropertyUriVariables.filter(value => securityUriVariables.includes(value))\n                            // console.log(curPropertyUriVariables,\"\\n\",securityUriVariables,\"\\n\",filteredArray)\n                            if(filteredArray.length>0){\n                                uriVariablesDistinctResult = \"fail\"\n                            } else {\n                                if (uriVariablesDistinctResult !== \"fail\"){\n                                    uriVariablesDistinctResult = \"pass\"\n                                }\n                            }\n                        } // otherwise not-impl stays\n                    }\n                }\n            }\n\n            if (td.hasOwnProperty(\"actions\")) {\n                // checking security in property level\n                let tdActions = Object.keys(td.actions)\n                for (let i = 0; i < tdActions.length; i++) {\n                    const curActionName = tdActions[i]\n                    const curAction = td.actions[curActionName]\n                    // checking href with uriVariable in forms level\n                    const curForms = curAction.forms\n                    for (let j = 0; j < curForms.length; j++) {\n                        const curForm = curForms[j]\n                        if (curForm.hasOwnProperty(\"href\")){\n                            const curHref = curForm.href\n                            // bottom thing is taken from https://stackoverflow.com/a/5582621/3806426\n                            if (securityUriVariables.some(v => curHref.includes(v))) {\n                                // There's at least one\n                                if(uriVariablesResult !== \"fail\"){\n                                    uriVariablesResult = \"pass\"\n                                }\n                            }\n                        }\n                    }\n                    // part for the check of td-security-uri-variables-distinct\n                    if (curAction.hasOwnProperty(\"uriVariables\")){\n                        let curActionUriVariables = Object.keys(curAction.uriVariables)\n                        curActionUriVariables.push(...rootUriVariables)\n                        if (curActionUriVariables.length>0){ // there are urivariables somewhere at least\n                            // below is from https://stackoverflow.com/a/1885569/3806426\n                            const filteredArray = curActionUriVariables.filter(value => securityUriVariables.includes(value))\n                            // console.log(curActionUriVariables,\"\\n\",securityUriVariables,\"\\n\",filteredArray)\n                            if(filteredArray.length>0){\n                                uriVariablesDistinctResult = \"fail\"\n                            } else {\n                                if (uriVariablesDistinctResult !== \"fail\"){\n                                    uriVariablesDistinctResult = \"pass\"\n                                }\n                            }\n                        } // otherwise not-impl stays\n                    }\n                }\n            }\n\n            if (td.hasOwnProperty(\"events\")) {\n                // checking security in property level\n                let tdEvents = Object.keys(td.events)\n                for (let i = 0; i < tdEvents.length; i++) {\n                    const curEventName = tdEvents[i]\n                    const curEvent = td.events[curEventName]\n                    // checking href with uriVariable in forms level\n                    const curForms = curEvent.forms\n                    for (let j = 0; j < curForms.length; j++) {\n                        const curForm = curForms[j]\n                        if (curForm.hasOwnProperty(\"href\")){\n                            const curHref = curForm.href\n                            // bottom thing is taken from https://stackoverflow.com/a/5582621/3806426\n                            if (securityUriVariables.some(v => curHref.includes(v))) {\n                                // There's at least one\n                                if(uriVariablesResult !== \"fail\"){\n                                    uriVariablesResult = \"pass\"\n                                }\n                            }\n                        }\n                    }\n                    // part for the check of td-security-uri-variables-distinct\n                    if (curEvent.hasOwnProperty(\"uriVariables\")){\n                        let curEventUriVariables = Object.keys(curEvent.uriVariables)\n                        curEventUriVariables.push(...rootUriVariables)\n                        if (curEventUriVariables.length>0){ // there are urivariables somewhere at least\n                            // below is from https://stackoverflow.com/a/1885569/3806426\n                            const filteredArray = curEventUriVariables.filter(value => securityUriVariables.includes(value))\n                            // console.log(curEventUriVariables,\"\\n\",securityUriVariables,\"\\n\",filteredArray)\n                            if(filteredArray.length>0){\n                                uriVariablesDistinctResult = \"fail\"\n                            } else {\n                                if (uriVariablesDistinctResult !== \"fail\"){\n                                    uriVariablesDistinctResult = \"pass\"\n                                }\n                            }\n                        } // otherwise not-impl stays\n                    }\n                }\n            }\n\n            results.push({\n                \"ID\": \"td-security-in-uri-variable\",\n                \"Status\": uriVariablesResult\n            })\n            results.push({\n                \"ID\": \"td-security-in-uri-variable-distinct\",\n                \"Status\": uriVariablesDistinctResult\n            })\n            return results\n\n        }\n\n        // // no security used non defined scheme, passed test\n        // results.push({\n        //     \"ID\": \"td-security-scheme-name\",\n        //     \"Status\": \"pass\"\n        // })\n        // return results\n\n    }\n    return results\n}\n\n/**\n * When tm:optional uses a pointer, it should point to an actual affordance and only to an affordance, as said by\n * tm-tmOptional-resolver: The JSON Pointers of tm:optional MUST resolve to an entire interaction affordance Map definition.\n * JSON Schema checks for the syntax but cannot know if the pointed affordance exists.\n * This function checks that programmatically\n * @param {object} td The TD to do assertion tests\n */\nfunction checkTmOptionalPointer(td){\n    const results = []\n    if(td.hasOwnProperty(\"tm:optional\")){\n        td[\"tm:optional\"].forEach(element => {\n            // However, tm: optional values start with / so it should be removed first\n            element = element.substring(1)\n            element = element.replace(\"/\",\".\") // since the resolvePath uses . instead of /\n            const pathTarget = resolvePath(td,element,\"noTarget\")\n            if (pathTarget === \"noTarget\" || pathTarget === undefined) {\n                results.push({\n                    \"ID\": \"tm-tmOptional-resolver\",\n                    \"Status\": \"fail\",\n                    \"Comment\": \"tm:optional does not resolve to an affordance\"\n                })\n            } else {\n                results.push({\n                    \"ID\": \"tm-tmOptional-resolver\",\n                    \"Status\": \"pass\",\n                    \"Comment\": \"\"\n                })\n            }\n        });\n    } else {\n        results.push({\n            \"ID\": \"tm-tmOptional-resolver\",\n            \"Status\": \"not-impl\",\n            \"Comment\": \"no use of tm:optional\"\n        })\n    }\n\n    return results\n }\n","import jsonld from 'jsonld';\nimport Ajv from 'ajv';\nimport addFormats from 'ajv-formats';\nimport apply from 'ajv-formats-draft2019';\nimport lzs from 'lz-string';\n\nimport {\n    checkPropUniqueness,\n    checkSecurity,\n    checkMultiLangConsistency,\n    checkLinksRelTypeCount,\n    checkUriSecurity,\n    checkTmOptionalPointer\n} from './shared';\nimport tdSchema from './td-schema.json';\nimport fullTdSchema from './td-schema-full.json';\nimport tmSchema from './tm-schema.json';\n\nimport jsonValidator from 'json-dup-key-validator';\n\nexport { tdValidator, tmValidator, compress, decompress, checkTypos }\n\n/**\n * A function that provides the core functionality of the TD Playground.\n * @param {string} tdString The Thing Description to check as a string.\n * @param {function} logFunc (string) => void; Callback used to log the validation progress.\n * @param {object} options additional options, which checks should be executed\n * @returns {Promise<object>} Results of the validation as {report, details, detailComments} object\n */\nfunction tdValidator(tdString, logFunc, { checkDefaults = true, checkJsonLd = true }) {\n    return new Promise((res, rej) => {\n\n        // check input\n        if (typeof tdString !== \"string\") {\n            rej(\"Thing Description input should be a String\")\n        }\n\n        if (checkDefaults === undefined) {\n            checkDefaults = true\n        }\n        if (checkJsonLd === undefined) {\n            checkJsonLd = true\n        }\n        if (typeof logFunc !== \"function\") {\n            rej(\"Expected logFunc to be a function\")\n        }\n\n        // report that is returned by the function, possible values for every property:\n        // null -> not tested, \"passed\", \"failed\", \"warning\"\n        const report = {\n            json: null,\n            schema: null,\n            defaults: null,\n            jsonld: null,\n            additional: null\n        }\n        // changing the two following objects implies adjusting the tests accordingly\n        const details = {\n            enumConst: null,\n            propItems: null,\n            security: null,\n            propUniqueness: null,\n            multiLangConsistency: null,\n            linksRelTypeCount: null,\n            readWriteOnly: null,\n            uriVariableSecurity: null\n        }\n\n        const detailComments = {\n            enumConst: \"Checking whether a data schema has enum and const at the same time.\",\n            propItems: \"Checking whether a data schema has an object but not properties or array but no items.\",\n            security: \"Check if used Security definitions are properly defined previously.\",\n            propUniqueness: \"Checking whether in one interaction pattern there are duplicate names, e.g. two properties called temp.\",\n            multiLangConsistency: \"Checks whether all titles and descriptions have the same language fields.\",\n            linksRelTypeCount: \"Checks whether rel:type is used more than once in the links array\",\n            readWriteOnly: \"Warns if a property has readOnly or writeOnly set to true conflicting with another property.\",\n            uriVariableSecurity: \"Checks if the name of an APIKey security scheme with in:uri show up in href and does not conflict with normal uriVariables\"\n        }\n\n        const validationErrors = {\n            json: null,\n            schema: null\n        }\n\n        let tdJson\n        try {\n            tdJson = JSON.parse(tdString)\n            report.json = \"passed\"\n        } catch (err) {\n            report.json = \"failed\"\n            logFunc(\"X JSON validation failed:\")\n            validationErrors.json = err.message;\n            logFunc(err)\n\n            res({ report, details, detailComments, validationErrors })\n        }\n\n        let ajv = new Ajv({ strict: false }) // options can be passed, e.g. {allErrors: true}\n\n        // ajv = addFormats(ajv) // ajv does not support formats by default anymore\n        ajv = apply(ajv) // new formats that include iri\n\n\n        ajv.addSchema(tdSchema, 'td')\n        const valid = ajv.validate('td', tdJson)\n        // used to be var valid = ajv.validate('td', e.detail);\n        if (valid) {\n\n            report.schema = \"passed\"\n\n            // check with full schema\n            if (checkDefaults) {\n                ajv.addSchema(fullTdSchema, 'fulltd')\n                const fullValid = ajv.validate('fulltd', tdJson)\n                if (fullValid) {\n                    report.defaults = \"passed\"\n                } else {\n                    report.defaults = \"warning\"\n                    logFunc(\"Optional validation failed:\")\n                    logFunc(\"> \" + ajv.errorsText(filterErrorMessages(ajv.errors)))\n                    res({ report, details, detailComments, validationErrors })\n                }\n            }\n\n            // do additional checks\n            checkEnumConst(tdJson)\n            checkPropItems(tdJson)\n            checkReadWriteOnly(tdJson)\n            details.security = evalAssertion(checkSecurity(tdJson))\n            details.propUniqueness = evalAssertion(checkPropUniqueness(tdString))\n            if (details.propUniqueness === \"passed\") {\n                details.propUniqueness = checkSecPropUniqueness(tdString, tdJson)\n            } else {\n                checkSecPropUniqueness(tdString, tdJson)\n            }\n            details.multiLangConsistency = evalAssertion(checkMultiLangConsistency(tdJson))\n            details.linksRelTypeCount = evalAssertion(checkLinksRelTypeCount(tdJson))\n            details.uriVariableSecurity = evalAssertion(checkUriSecurity(tdJson))\n\n            // determine additional check state\n            // passed + warning -> warning\n            // passed AND OR warning + error -> error\n            report.additional = \"passed\"\n            Object.keys(details).forEach(prop => {\n                if (details[prop] === \"warning\" && report.additional === \"passed\") {\n                    report.additional = \"warning\"\n                } else if (details[prop] === \"failed\" && report.additional !== \"failed\") {\n                    report.additional = \"failed\"\n                }\n            })\n\n        } else {\n\n            report.schema = \"failed\"\n            logFunc(\"X JSON Schema validation failed:\")\n            validationErrors.schema = ajv.errorsText(filterErrorMessages(ajv.errors))\n            logFunc('> ' + validationErrors.schema)\n\n            res({ report, details, detailComments, validationErrors })\n        }\n\n        // json ld validation\n        if (checkJsonLd) {\n            jsonld.toRDF(tdJson, {\n                format: 'application/nquads'\n            }).then(nquads => {\n                report.jsonld = \"passed\"\n                res({ report, details, detailComments })\n            }, err => {\n                report.jsonld = \"failed\"\n                logFunc(\"X JSON-LD validation failed:\")\n                logFunc(\"Hint: Make sure you have internet connection available.\")\n                logFunc('> ' + err)\n                res({ report, details, detailComments })\n            })\n        } else {\n            res({ report, details, detailComments })\n        }\n\n\n        // ************ functions ***************\n\n        /** checking whether a data schema has enum and const at the same and displaying a warning in case there are */\n        function checkEnumConst(td) {\n            details.enumConst = \"passed\"\n            if (td.hasOwnProperty(\"properties\")) {\n                // checking properties\n                let tdProperties = Object.keys(td.properties)\n                for (let i = 0; i < tdProperties.length; i++) {\n                    const curPropertyName = tdProperties[i]\n                    const curProperty = td.properties[curPropertyName]\n                    if (curProperty.hasOwnProperty(\"enum\") && curProperty.hasOwnProperty(\"const\")) {\n                        details.enumConst = \"warning\"\n                        logFunc('! Warning: In property ' + curPropertyName +\n                            ' enum and const are used at the same time, the values in enum' +\n                            ' can never be valid in the received JSON value')\n                    }\n                }\n            }\n            // checking actions\n            if (td.hasOwnProperty(\"actions\")) {\n                let tdActions = Object.keys(td.actions)\n                for (let i = 0; i < tdActions.length; i++) {\n                    const curActionName = tdActions[i]\n                    const curAction = td.actions[curActionName]\n                    if (curAction.hasOwnProperty(\"input\")) {\n                        const curInput = curAction.input\n                        if (curInput.hasOwnProperty(\"enum\") && curInput.hasOwnProperty(\"const\")) {\n                            details.enumConst = \"warning\"\n                            logFunc('! Warning: In the input of action ' + curActionName +\n                                ' enum and const are used at the same time, the values in enum can' +\n                                ' never be valid in the received JSON value')\n                        }\n                    }\n                    if (curAction.hasOwnProperty(\"output\")) {\n                        const curOutput = curAction.output\n                        if (curOutput.hasOwnProperty(\"enum\") && curOutput.hasOwnProperty(\"const\")) {\n                            details.enumConst = \"warning\"\n                            logFunc('! Warning: In the output of action ' + curActionName +\n                                ' enum and const are used at the same time, the values in enum can' +\n                                ' never be valid in the received JSON value')\n\n                        }\n                    }\n                }\n            }\n            // checking events\n            if (td.hasOwnProperty(\"events\")) {\n                let tdEvents = Object.keys(td.events)\n                for (let i = 0; i < tdEvents.length; i++) {\n                    const curEventName = tdEvents[i]\n                    const curEvent = td.events[curEventName]\n                    if (curEvent.hasOwnProperty(\"enum\") && curEvent.hasOwnProperty(\"const\")) {\n                        details.enumConst = \"warning\"\n                        logFunc('! Warning: In event ' + curEventName +\n                            ' enum and const are used at the same time, the' +\n                            ' values in enum can never be valid in the received JSON value')\n                    }\n                }\n            }\n            return\n        }\n\n        /**\n         * checking whether a data schema has object but not properties, array but no items\n         * @param {object} td The TD under test\n         */\n        function checkPropItems(td) {\n            details.propItems = \"passed\"\n\n            if (td.hasOwnProperty(\"properties\")) {\n                // checking properties\n                let tdProperties = Object.keys(td.properties)\n                for (let i = 0; i < tdProperties.length; i++) {\n                    const curPropertyName = tdProperties[i]\n                    const curProperty = td.properties[curPropertyName]\n\n                    if (curProperty.hasOwnProperty(\"type\")) {\n                        if ((curProperty.type === \"object\") && !(curProperty.hasOwnProperty(\"properties\"))) {\n                            details.propItems = \"warning\"\n                            logFunc('! Warning: In property ' + curPropertyName +\n                                ', the type is object but its properties are not specified')\n                        }\n                        if ((curProperty.type === \"array\") && !(curProperty.hasOwnProperty(\"items\"))) {\n                            details.propItems = \"warning\"\n                            logFunc('! Warning: In property ' + curPropertyName +\n                                ', the type is array but its items are not specified')\n                        }\n                    }\n                }\n            }\n            // checking actions\n            if (td.hasOwnProperty(\"actions\")) {\n                let tdActions = Object.keys(td.actions)\n                for (let i = 0; i < tdActions.length; i++) {\n                    const curActionName = tdActions[i]\n                    const curAction = td.actions[curActionName]\n\n                    if (curAction.hasOwnProperty(\"input\")) {\n                        const curInput = curAction.input\n                        if (curInput.hasOwnProperty(\"type\")) {\n                            if ((curInput.type === \"object\") && !(curInput.hasOwnProperty(\"properties\"))) {\n                                details.propItems = \"warning\"\n                                logFunc('! Warning: In the input of action ' + curActionName +\n                                    ', the type is object but its properties are not specified')\n                            }\n                            if ((curInput.type === \"array\") && !(curInput.hasOwnProperty(\"items\"))) {\n                                details.propItems = \"warning\"\n                                logFunc('! Warning: In the output of action ' + curActionName +\n                                    ', the type is array but its items are not specified')\n                            }\n                        }\n                    }\n                    if (curAction.hasOwnProperty(\"output\")) {\n                        const curOutput = curAction.output\n                        if (curOutput.hasOwnProperty(\"type\")) {\n                            if ((curOutput.type === \"object\") && !(curOutput.hasOwnProperty(\"properties\"))) {\n                                details.propItems = \"warning\"\n                                logFunc('! Warning: In the output of action ' + curActionName +\n                                    ', the type is object but its properties are not specified')\n                            }\n                            if ((curOutput.type === \"array\") && !(curOutput.hasOwnProperty(\"items\"))) {\n                                details.propItems = \"warning\"\n                                logFunc('! Warning: In the output of action ' + curActionName +\n                                    ', the type is array but its items are not specified')\n                            }\n                        }\n                    }\n                }\n            }\n            // checking events\n            if (td.hasOwnProperty(\"events\")) {\n                let tdEvents = Object.keys(td.events)\n                for (let i = 0; i < tdEvents.length; i++) {\n                    const curEventName = tdEvents[i]\n                    const curEvent = td.events[curEventName]\n\n                    if (curEvent.hasOwnProperty(\"type\")) {\n                        if ((curEvent.type === \"object\") && !(curEvent.hasOwnProperty(\"properties\"))) {\n                            details.propItems = \"warning\"\n                            logFunc('! Warning: In event ' + curEventName +\n                                ', the type is object but its properties are not specified')\n                        }\n                        if ((curEvent.type === \"array\") && !(curEvent.hasOwnProperty(\"items\"))) {\n                            details.propItems = \"warning\"\n                            logFunc('! Warning: In event ' + curEventName +\n                                ', the type is array but its items are not specified')\n\n                        }\n                    }\n\n                }\n            }\n            return\n        }\n\n        /**\n         * Warns if a property has readOnly or writeOnly set to true conflicting with another property.\n         * @param {object} td The TD under test\n         */\n        function checkReadWriteOnly(td) {\n            details.readWriteOnly = \"passed\"\n\n            if (td.hasOwnProperty(\"properties\")) {\n                // checking properties\n                let tdProperties = Object.keys(td.properties)\n                for (let i = 0; i < tdProperties.length; i++) {\n                    const curPropertyName = tdProperties[i]\n                    const curProperty = td.properties[curPropertyName]\n\n                    // if readOnly is set\n                    if (curProperty.hasOwnProperty(\"readOnly\") && curProperty.readOnly === true) {\n                        // check if both readOnly and writeOnly are true\n                        if (curProperty.hasOwnProperty(\"writeOnly\") && curProperty.writeOnly === true) {\n                            details.readWriteOnly = \"warning\"\n                            logFunc('! Warning: In property ' + curPropertyName +\n                                ', both readOnly and writeOnly are set to true!')\n                        }\n\n                        // check forms if op writeProperty is set\n                        if (curProperty.hasOwnProperty(\"forms\")) {\n                            for (const formElIndex in curProperty.forms) {\n                                if (curProperty.forms.hasOwnProperty(formElIndex)) {\n                                    const formEl = curProperty.forms[formElIndex]\n                                    if (formEl.hasOwnProperty(\"op\")) {\n                                        if ((typeof formEl.op === \"string\" && formEl.op === \"writeproperty\") ||\n                                            (typeof formEl.op === \"object\" && formEl.op.some(el => (el === \"writeproperty\")))) {\n                                            details.readWriteOnly = \"warning\"\n                                            logFunc('! Warning: In property ' + curPropertyName + \" in forms[\" + formElIndex +\n                                                '], readOnly is set but the op property contains \"writeproperty\"')\n                                        }\n                                    } else {\n                                        details.readWriteOnly = \"warning\"\n                                        logFunc('! Warning: In property ' + curPropertyName + \" in forms[\" + formElIndex +\n                                            '], readOnly is set but a form op property defaults to [\"writeproperty\", \"readproperty\"]')\n                                    }\n                                }\n                            }\n                        }\n                    }\n\n                    // if writeOnly is set\n                    if (curProperty.hasOwnProperty(\"writeOnly\") && curProperty.writeOnly === true) {\n\n                        // check forms if op readProperty is set\n                        if (curProperty.hasOwnProperty(\"forms\")) {\n                            for (const formElIndex in curProperty.forms) {\n                                if (curProperty.forms.hasOwnProperty(formElIndex)) {\n                                    const formEl = curProperty.forms[formElIndex]\n                                    if (formEl.hasOwnProperty(\"op\")) {\n                                        if ((typeof formEl.op === \"string\" && formEl.op === \"readproperty\") ||\n                                            (typeof formEl.op === \"object\" && formEl.op.some(el => (el === \"readproperty\")))) {\n                                            details.readWriteOnly = \"warning\"\n                                            logFunc('! Warning: In property ' + curPropertyName + \" in forms[\" + formElIndex +\n                                                '], writeOnly is set but the op property contains \"readproperty\"')\n                                        } else if ((typeof formEl.op === \"string\" && formEl.op === \"observeproperty\") ||\n                                            (typeof formEl.op === \"object\" && formEl.op.some(el => (el === \"observeproperty\")))) {\n                                            details.readWriteOnly = \"warning\"\n                                            logFunc('! Warning: In property ' + curPropertyName + \" in forms[\" + formElIndex +\n                                                '], writeOnly is set but the op property contains \"observeproperty\"')\n                                        }\n                                    } else {\n                                        details.readWriteOnly = \"warning\"\n                                        logFunc('! Warning: In property ' + curPropertyName + \" in forms[\" + formElIndex +\n                                            '], writeOnly is set but a form op property defaults to [\"writeproperty\", \"readproperty\"]')\n                                    }\n                                }\n                            }\n                        }\n\n                        // check if observable is also set\n                        if (curProperty.hasOwnProperty(\"observable\") && curProperty.observable === true) {\n                            details.readWriteOnly = \"warning\"\n                            logFunc('! Warning: In property ' + curPropertyName +\n                                ', both writeOnly and observable are set to true!')\n                        }\n                    }\n                }\n            }\n        }\n\n        /**\n         * Warns if security Definitions has no unique keys\n         * @param {object} tdStr The TD under test as string\n         */\n        function checkSecPropUniqueness(tdStr, td) {\n\n            let result = \"passed\"\n            try {\n                // checking whether there are securityDefinitions at all\n                jsonValidator.parse(tdStr, false)\n            } catch (error) {\n                // there is a duplicate somewhere\n\n                // convert it into string to be able to process it\n                // error is of form = Error: Syntax error: duplicated keys \"overheating\" near ting\": {\n                const errorString = error.toString()\n                // to get the name, we need to remove the quotes around it\n                const startQuote = errorString.indexOf('\"')\n                // slice to remove the part before the quote\n                const restString = errorString.slice(startQuote + 1)\n                // find where the interaction name ends\n                const endQuote = restString.indexOf('\"')\n                // finally get the interaction name\n                const securitySchemeName = restString.slice(0, endQuote)\n\n                if (td.securityDefinitions.hasOwnProperty(securitySchemeName)) {\n                    result = \"failed\"\n                    logFunc(\"KO Error: The securityDefinitions contain a duplicate\")\n                }\n            }\n\n            return result\n        }\n\n        /**\n         * Evaluates whether an assertion function contains a failed check\n         * Whether assertions are not-implemented or passed does not matter\n         * Logs the comment\n         * @param {Array} results Array of objects with props \"ID\", \"Status\" and optionally \"Comment\"\n         * @returns \"passed\" if no check failed, \"failed\" if one or more checks failed\n         */\n        function evalAssertion(results) {\n            let out = \"passed\"\n            results.forEach(resultobj => {\n                if (resultobj.Status === \"fail\") {\n                    out = \"failed\"\n                    logFunc(\"KO Error: Assertion: \" + resultobj.ID)\n                    logFunc(resultobj.Comment)\n                }\n            })\n            return out\n        }\n\n        /**\n         * Removes duplicate error messages, as these are produced\n         * otherwise, especially for \"oneOf\" schemes\n         * @param {ajv.ErrorObject[]} errors\n         */\n        function filterErrorMessages(errors) {\n\n            const output = []\n            errors.forEach(el => {\n                if (!output.some(ce => (ce.dataPath === el.dataPath && ce.message === el.message))) {\n                    output.push(el)\n                }\n            })\n            return output\n        }\n    })\n}\n/**\n * A function that provides the core functionality of the TD Playground.\n * @param {string} tmString The Thing Model to check as a string.\n * @param {function} logFunc (string) => void; Callback used to log the validation progress.\n * @param {object} options additional options, which checks should be executed\n * @returns {Promise<object>} Results of the validation as {report, details, detailComments} object\n */\nfunction tmValidator(tmString, logFunc, { checkDefaults = true, checkJsonLd = true }) {\n    return new Promise((res, rej) => {\n\n        // check input\n        if (typeof tmString !== \"string\") { rej(\"Thing Model input should be a String\") }\n\n        if (checkDefaults === undefined) {\n            checkDefaults = true\n        }\n        if (checkJsonLd === undefined) {\n            checkJsonLd = true\n        }\n        if (typeof logFunc !== \"function\") { rej(\"Expected logFunc to be a function\") }\n\n        // report that is returned by the function, possible values for every property:\n        // null -> not tested, \"passed\", \"failed\", \"warning\"\n        const report = {\n            json: null,\n            schema: null,\n            defaults: null,\n            jsonld: null,\n            additional: null\n        }\n        // changing the two following objects implies adjusting the tests accordingly\n        const details = {\n            enumConst: null,\n            propItems: null,\n            propUniqueness: null,\n            multiLangConsistency: null,\n            linksRelTypeCount: null,\n            readWriteOnly: null,\n            tmOptionalPointer: null\n        }\n\n        const detailComments = {\n            enumConst: \"Checking whether a data schema has enum and const at the same time.\",\n            propItems: \"Checking whether a data schema has an object but not properties or array but no items.\",\n            propUniqueness: \"Checking whether in one interaction pattern there are duplicate names, e.g. two properties called temp.\",\n            multiLangConsistency: \"Checks whether all titles and descriptions have the same language fields.\",\n            linksRelTypeCount: \"Checks whether rel:type is used more than once in the links array\",\n            readWriteOnly: \"Warns if a property has readOnly or writeOnly set to true conflicting with another property.\",\n            tmOptionalPointer: \"Checking whether tm:optional points to an actual affordance\"\n        }\n\n        let tmJson\n        try {\n            tmJson = JSON.parse(tmString)\n            report.json = \"passed\"\n        }\n        catch (err) {\n            report.json = \"failed\"\n            logFunc(\"X JSON validation failed:\")\n            logFunc(err)\n\n            res({ report, details, detailComments })\n        }\n\n        let ajv = new Ajv({ strict: false }) // options can be passed, e.g. {allErrors: true}\n        ajv = addFormats(ajv) // ajv does not support formats by default anymore\n        ajv = apply(ajv) // new formats that include iri\n\n        ajv.addSchema(tmSchema, 'tm')\n        const valid = ajv.validate('tm', tmJson)\n        // used to be var valid = ajv.validate('td', e.detail);\n        if (valid) {\n\n            report.schema = \"passed\"\n\n            // do additional checks\n            checkEnumConst(tmJson)\n            checkPropItems(tmJson)\n            checkReadWriteOnly(tmJson)\n            // ! no need to do security checking\n            // details.security = evalAssertion(checkSecurity(tmJson))\n            details.propUniqueness = evalAssertion(checkPropUniqueness(tmString))\n            if (details.propUniqueness === \"passed\") {\n                details.propUniqueness = checkSecPropUniqueness(tmString, tmJson)\n            }\n            else {\n                checkSecPropUniqueness(tmString, tmJson)\n            }\n            details.multiLangConsistency = evalAssertion(checkMultiLangConsistency(tmJson))\n            details.linksRelTypeCount = evalAssertion(checkLinksRelTypeCount(tmJson))\n            details.tmOptionalPointer = evalAssertion(checkTmOptionalPointer(tmJson))\n\n            // determine additional check state\n            // passed + warning -> warning\n            // passed AND OR warning + error -> error\n            report.additional = \"passed\"\n            Object.keys(details).forEach(prop => {\n                if (details[prop] === \"warning\" && report.additional === \"passed\") {\n                    report.additional = \"warning\"\n                }\n                else if (details[prop] === \"failed\" && report.additional !== \"failed\") {\n                    report.additional = \"failed\"\n                }\n            })\n\n        } else {\n\n            report.schema = \"failed\"\n            logFunc(\"X JSON Schema validation failed:\")\n\n            logFunc('> ' + ajv.errorsText(filterErrorMessages(ajv.errors)))\n\n            res({ report, details, detailComments })\n        }\n\n        // json ld validation\n        if (checkJsonLd) {\n            jsonld.toRDF(tmJson, {\n                format: 'application/nquads'\n            }).then(nquads => {\n                report.jsonld = \"passed\"\n                res({ report, details, detailComments })\n            }, err => {\n                report.jsonld = \"failed\"\n                logFunc(\"X JSON-LD validation failed:\")\n                logFunc(\"Hint: Make sure you have internet connection available.\")\n                logFunc('> ' + err)\n                res({ report, details, detailComments })\n            })\n        }\n        else {\n            res({ report, details, detailComments })\n        }\n\n\n        // ************ functions ***************\n\n        /** checking whether a data schema has enum and const at the same and displaying a warning in case there are */\n        function checkEnumConst(tm) {\n            details.enumConst = \"passed\"\n            if (tm.hasOwnProperty(\"properties\")) {\n                // checking properties\n                let tmProperties = Object.keys(tm.properties)\n                for (let i = 0; i < tmProperties.length; i++) {\n                    const curPropertyName = tmProperties[i]\n                    const curProperty = tm.properties[curPropertyName]\n                    if (curProperty.hasOwnProperty(\"enum\") && curProperty.hasOwnProperty(\"const\")) {\n                        details.enumConst = \"warning\"\n                        logFunc('! Warning: In property ' + curPropertyName +\n                            ' enum and const are used at the same time, the values in enum' +\n                            ' can never be valid in the received JSON value')\n                    }\n                }\n            }\n            // checking actions\n            if (tm.hasOwnProperty(\"actions\")) {\n                let tmActions = Object.keys(tm.actions)\n                for (let i = 0; i < tmActions.length; i++) {\n                    const curActionName = tmActions[i]\n                    const curAction = tm.actions[curActionName]\n                    if (curAction.hasOwnProperty(\"input\")) {\n                        const curInput = curAction.input\n                        if (curInput.hasOwnProperty(\"enum\") && curInput.hasOwnProperty(\"const\")) {\n                            details.enumConst = \"warning\"\n                            logFunc('! Warning: In the input of action ' + curActionName +\n                                ' enum and const are used at the same time, the values in enum can' +\n                                ' never be valid in the received JSON value')\n                        }\n                    }\n                    if (curAction.hasOwnProperty(\"output\")) {\n                        const curOutput = curAction.output\n                        if (curOutput.hasOwnProperty(\"enum\") && curOutput.hasOwnProperty(\"const\")) {\n                            details.enumConst = \"warning\"\n                            logFunc('! Warning: In the output of action ' + curActionName +\n                                ' enum and const are used at the same time, the values in enum can' +\n                                ' never be valid in the received JSON value')\n\n                        }\n                    }\n                }\n            }\n            // checking events\n            if (tm.hasOwnProperty(\"events\")) {\n                let tmEvents = Object.keys(tm.events)\n                for (let i = 0; i < tmEvents.length; i++) {\n                    const curEventName = tmEvents[i]\n                    const curEvent = tm.events[curEventName]\n                    if (curEvent.hasOwnProperty(\"enum\") && curEvent.hasOwnProperty(\"const\")) {\n                        details.enumConst = \"warning\"\n                        logFunc('! Warning: In event ' + curEventName +\n                            ' enum and const are used at the same time, the' +\n                            ' values in enum can never be valid in the received JSON value')\n                    }\n                }\n            }\n            return\n        }\n\n        /**\n         * checking whether a data schema has object but not properties, array but no items\n         * @param {object} tm The TD under test\n         */\n        function checkPropItems(tm) {\n            details.propItems = \"passed\"\n\n            if (tm.hasOwnProperty(\"properties\")) {\n                // checking properties\n                let tmProperties = Object.keys(tm.properties)\n                for (let i = 0; i < tmProperties.length; i++) {\n                    const curPropertyName = tmProperties[i]\n                    const curProperty = tm.properties[curPropertyName]\n\n                    if (curProperty.hasOwnProperty(\"type\")) {\n                        if ((curProperty.type === \"object\") && !(curProperty.hasOwnProperty(\"properties\"))) {\n                            details.propItems = \"warning\"\n                            logFunc('! Warning: In property ' + curPropertyName +\n                                ', the type is object but its properties are not specified')\n                        }\n                        if ((curProperty.type === \"array\") && !(curProperty.hasOwnProperty(\"items\"))) {\n                            details.propItems = \"warning\"\n                            logFunc('! Warning: In property ' + curPropertyName +\n                                ', the type is array but its items are not specified')\n                        }\n                    }\n                }\n            }\n            // checking actions\n            if (tm.hasOwnProperty(\"actions\")) {\n                let tmActions = Object.keys(tm.actions)\n                for (let i = 0; i < tmActions.length; i++) {\n                    const curActionName = tmActions[i]\n                    const curAction = tm.actions[curActionName]\n\n                    if (curAction.hasOwnProperty(\"input\")) {\n                        const curInput = curAction.input\n                        if (curInput.hasOwnProperty(\"type\")) {\n                            if ((curInput.type === \"object\") && !(curInput.hasOwnProperty(\"properties\"))) {\n                                details.propItems = \"warning\"\n                                logFunc('! Warning: In the input of action ' + curActionName +\n                                    ', the type is object but its properties are not specified')\n                            }\n                            if ((curInput.type === \"array\") && !(curInput.hasOwnProperty(\"items\"))) {\n                                details.propItems = \"warning\"\n                                logFunc('! Warning: In the output of action ' + curActionName +\n                                    ', the type is array but its items are not specified')\n                            }\n                        }\n                    }\n                    if (curAction.hasOwnProperty(\"output\")) {\n                        const curOutput = curAction.output\n                        if (curOutput.hasOwnProperty(\"type\")) {\n                            if ((curOutput.type === \"object\") && !(curOutput.hasOwnProperty(\"properties\"))) {\n                                details.propItems = \"warning\"\n                                logFunc('! Warning: In the output of action ' + curActionName +\n                                    ', the type is object but its properties are not specified')\n                            }\n                            if ((curOutput.type === \"array\") && !(curOutput.hasOwnProperty(\"items\"))) {\n                                details.propItems = \"warning\"\n                                logFunc('! Warning: In the output of action ' + curActionName +\n                                    ', the type is array but its items are not specified')\n                            }\n                        }\n                    }\n                }\n            }\n            // checking events\n            if (tm.hasOwnProperty(\"events\")) {\n                let tmEvents = Object.keys(tm.events)\n                for (let i = 0; i < tmEvents.length; i++) {\n                    const curEventName = tmEvents[i]\n                    const curEvent = tm.events[curEventName]\n\n                    if (curEvent.hasOwnProperty(\"type\")) {\n                        if ((curEvent.type === \"object\") && !(curEvent.hasOwnProperty(\"properties\"))) {\n                            details.propItems = \"warning\"\n                            logFunc('! Warning: In event ' + curEventName +\n                                ', the type is object but its properties are not specified')\n                        }\n                        if ((curEvent.type === \"array\") && !(curEvent.hasOwnProperty(\"items\"))) {\n                            details.propItems = \"warning\"\n                            logFunc('! Warning: In event ' + curEventName +\n                                ', the type is array but its items are not specified')\n\n                        }\n                    }\n\n                }\n            }\n            return\n        }\n\n        /**\n         * Warns if a property has readOnly or writeOnly set to true conflicting with another property.\n         * @param {object} tm The TD under test\n         */\n        function checkReadWriteOnly(tm) {\n            details.readWriteOnly = \"passed\"\n\n            if (tm.hasOwnProperty(\"properties\")) {\n                // checking properties\n                let tmProperties = Object.keys(tm.properties)\n                for (let i = 0; i < tmProperties.length; i++) {\n                    const curPropertyName = tmProperties[i]\n                    const curProperty = tm.properties[curPropertyName]\n\n                    // if readOnly is set\n                    if (curProperty.hasOwnProperty(\"readOnly\") && curProperty.readOnly === true) {\n                        // check if both readOnly and writeOnly are true\n                        if (curProperty.hasOwnProperty(\"writeOnly\") && curProperty.writeOnly === true) {\n                            details.readWriteOnly = \"warning\"\n                            logFunc('! Warning: In property ' + curPropertyName +\n                                ', both readOnly and writeOnly are set to true!')\n                        }\n\n                        // check forms if op writeProperty is set\n                        if (curProperty.hasOwnProperty(\"forms\")) {\n                            for (const formElIndex in curProperty.forms) {\n                                if (curProperty.forms.hasOwnProperty(formElIndex)) {\n                                    const formEl = curProperty.forms[formElIndex]\n                                    if (formEl.hasOwnProperty(\"op\")) {\n                                        if ((typeof formEl.op === \"string\" && formEl.op === \"writeproperty\") ||\n                                            (typeof formEl.op === \"object\" && formEl.op.some(el => (el === \"writeproperty\")))) {\n                                            details.readWriteOnly = \"warning\"\n                                            logFunc('! Warning: In property ' + curPropertyName + \" in forms[\" + formElIndex +\n                                                '], readOnly is set but the op property contains \"writeproperty\"')\n                                        }\n                                    }\n                                    else {\n                                        details.readWriteOnly = \"warning\"\n                                        logFunc('! Warning: In property ' + curPropertyName + \" in forms[\" + formElIndex +\n                                            '], readOnly is set but a form op property defaults to [\"writeproperty\", \"readproperty\"]')\n                                    }\n                                }\n                            }\n                        }\n                    }\n\n                    // if writeOnly is set\n                    if (curProperty.hasOwnProperty(\"writeOnly\") && curProperty.writeOnly === true) {\n\n                        // check forms if op readProperty is set\n                        if (curProperty.hasOwnProperty(\"forms\")) {\n                            for (const formElIndex in curProperty.forms) {\n                                if (curProperty.forms.hasOwnProperty(formElIndex)) {\n                                    const formEl = curProperty.forms[formElIndex]\n                                    if (formEl.hasOwnProperty(\"op\")) {\n                                        if ((typeof formEl.op === \"string\" && formEl.op === \"readproperty\") ||\n                                            (typeof formEl.op === \"object\" && formEl.op.some(el => (el === \"readproperty\")))) {\n                                            details.readWriteOnly = \"warning\"\n                                            logFunc('! Warning: In property ' + curPropertyName + \" in forms[\" + formElIndex +\n                                                '], writeOnly is set but the op property contains \"readproperty\"')\n                                        }\n                                        else if ((typeof formEl.op === \"string\" && formEl.op === \"observeproperty\") ||\n                                            (typeof formEl.op === \"object\" && formEl.op.some(el => (el === \"observeproperty\")))) {\n                                            details.readWriteOnly = \"warning\"\n                                            logFunc('! Warning: In property ' + curPropertyName + \" in forms[\" + formElIndex +\n                                                '], writeOnly is set but the op property contains \"observeproperty\"')\n                                        }\n                                    }\n                                    else {\n                                        details.readWriteOnly = \"warning\"\n                                        logFunc('! Warning: In property ' + curPropertyName + \" in forms[\" + formElIndex +\n                                            '], writeOnly is set but a form op property defaults to [\"writeproperty\", \"readproperty\"]')\n                                    }\n                                }\n                            }\n                        }\n\n                        // check if observable is also set\n                        if (curProperty.hasOwnProperty(\"observable\") && curProperty.observable === true) {\n                            details.readWriteOnly = \"warning\"\n                            logFunc('! Warning: In property ' + curPropertyName +\n                                ', both writeOnly and observable are set to true!')\n                        }\n                    }\n                }\n            }\n        }\n\n        /**\n         * Warns if security Definitions has no unique keys\n         * @param {object} tmStr The TD under test as string\n         */\n        function checkSecPropUniqueness(tmStr, tm) {\n\n            let result = \"passed\"\n            try {\n                // checking whether there are securityDefinitions at all\n                jsonValidator.parse(tmStr, false)\n            }\n            catch (error) {\n                // there is a duplicate somewhere\n\n                // convert it into string to be able to process it\n                // error is of form = Error: Syntax error: duplicated keys \"overheating\" near ting\": {\n                const errorString = error.toString()\n                // to get the name, we need to remove the quotes around it\n                const startQuote = errorString.indexOf('\"')\n                // slice to remove the part before the quote\n                const restString = errorString.slice(startQuote + 1)\n                // find where the interaction name ends\n                const endQuote = restString.indexOf('\"')\n                // finally get the interaction name\n                const securitySchemeName = restString.slice(0, endQuote)\n\n                if (tm.securityDefinitions.hasOwnProperty(securitySchemeName)) {\n                    result = \"failed\"\n                    logFunc(\"KO Error: The securityDefinitions contain a duplicate\")\n                }\n            }\n\n            return result\n        }\n\n        /**\n         * Evaluates whether an assertion function contains a failed check\n         * Whether assertions are not-implemented or passed does not matter\n         * Logs the comment\n         * @param {Array} results Array of objects with props \"ID\", \"Status\" and optionally \"Comment\"\n         * @returns \"passed\" if no check failed, \"failed\" if one or more checks failed\n         */\n        function evalAssertion(results) {\n            let out = \"passed\"\n            results.forEach(resultobj => {\n                if (resultobj.Status === \"fail\") {\n                    out = \"failed\"\n                    logFunc(\"KO Error: Assertion: \" + resultobj.ID)\n                    logFunc(resultobj.Comment)\n                }\n            })\n            return out\n        }\n\n        /**\n         * Removes duplicate error messages, as these are produced\n         * otherwise, especially for \"oneOf\" schemes\n         * @param {ajv.ErrorObject[]} errors\n         */\n        function filterErrorMessages(errors) {\n\n            const output = []\n            errors.forEach(el => {\n                if (!output.some(ce => (ce.dataPath === el.dataPath && ce.message === el.message))) {\n                    output.push(el)\n                }\n            })\n            return output\n        }\n    })\n}\n\n/**\n * Transform an arbitrary string to another compressed URL-encoded string.\n * @param {string} data String to compress.\n * @returns {string} Compressed URL-encoded string.\n */\nfunction compress(data) {\n    return lzs.compressToEncodedURIComponent(data);\n}\n\n/**\n * Decompress a string compressed with the {@link compress} method.\n * @param {string} data Compressed URL-encoded string.\n * @returns {string} Original string.\n */\nfunction decompress(data) {\n    return lzs.decompressFromEncodedURIComponent(data);\n}\n\n// --------------------------------------------------\n\n// -------------------------------------------------- checkTypos\n\nconst REF = \"$ref\"\nconst PROPERTIES = \"properties\"\nconst ADDITONAL_PROPERTIES = \"additional_properties\"\nconst DATA_SCHEMA = \"dataSchema\"\nconst PATH = \"#/\"\nconst TYPO_LOOKUP_TABLE = createSchemaLookupTable(tdSchema)\n\n/**\n * Checks possible typos in a TD\n * @param {object} td The TD to apply typo check on\n * @returns List of possible typos where the typo consists of string value of typo itself and the message, another string value, to be prompted to the user for the fix\n */\nfunction checkTypos(td) {\n    const typos = []\n\n    const lookupTable = TYPO_LOOKUP_TABLE\n    const searchDepth = 1\n    const searchPath = PATH\n    let tdJson = {}\n\n    try {\n        tdJson = JSON.parse(td)\n    } catch (err) {\n        console.log(\"Error occurred while parsing JSON!\")\n    }\n\n    searchTypos(typos, tdJson, lookupTable, searchDepth, searchPath)\n\n    return typos\n}\n\n/**\n * Searching typos on a specific path and depth\n * @param {Array} typos The list that typo objects are stored\n * @param {object} tdJson JSON object of the TD\n * @param {Map} lookupTable The map that stores paths and their available word list according to their path depth\n * @param {integer} searchDepth The integer that decides the depth of the typo check search\n * @param {string} searchPath The string that decided the path of the typo check search\n */\nfunction searchTypos(typos, tdJson, lookupTable, searchDepth, searchPath) {\n    for (const key in tdJson) {\n        if (tdJson.hasOwnProperty(key)) {\n            const pathMap = lookupTable.get(searchDepth)\n            const wordSet = pathMap.get(searchPath)\n\n            if (wordSet.has(key)) {\n                continue\n            }\n\n            wordSet.forEach(word => {\n                if (doesTypoExist(key, word)) {\n                    typos.push({\n                        word: key,\n                        message: `Did you mean ${word}?`\n                    })\n\n                    return\n                }\n            })\n        }\n    }\n}\n\n/**\n * Creates a lookup table using JSON schema\n * @param {object} jsonSchema JSON Schema to create a lookup table from\n * @returns The map that constructs lookup table for typo check using TD Schema\n */\nfunction createSchemaLookupTable(jsonSchema) {\n    const lookupTable = new Map()\n    const filteredLookupTable = new Map()\n\n    findPathsInSchema(lookupTable, jsonSchema, PATH)\n\n    lookupTable.forEach((value, key) => {\n        if (value.size > 0) {\n            const pathDepth = (key.match(/\\//ig) || []).length\n\n            let pathDepthMap = filteredLookupTable.get(pathDepth)\n\n            if (pathDepthMap) {\n                pathDepthMap.set(key.replace(/^r/g, ''), value)\n                filteredLookupTable.set(pathDepth, pathDepthMap)\n            } else {\n                pathDepthMap = new Map()\n                pathDepthMap.set(key.replace(/^r/g, ''), value)\n                filteredLookupTable.set(pathDepth, pathDepthMap)\n            }\n        }\n    })\n\n    return filteredLookupTable\n}\n\n/**\n * Finds the paths under a parent path by parsing schema and adds them to a lookup table\n * @param {Map} lookupTable The map that stores the paths in the schema\n * @param {object} schema The schema to find the paths from\n * @param {string} path The parent path that search is going under\n */\nfunction findPathsInSchema(lookupTable, schema, path) {\n    const keys = new Set()\n\n    if (schema[REF]) {\n        if (path[0] === 'r' && schema[REF].includes(DATA_SCHEMA)) {\n            return\n        }\n\n        if (schema[REF].includes(DATA_SCHEMA)) {\n            path = 'r' + path\n        }\n\n        findPathsInSchema(getRefObjectOfSchema(tdSchema, schema[REF]), path)\n        return\n    }\n\n    if (schema['type'] === 'object') {\n        const properties = schema[PROPERTIES]\n        for (const key in properties) {\n            if (properties.hasOwnProperty(key)) {\n                if (key === REF) {\n                    if (path[0] === 'r' && properties[key].includes(DATA_SCHEMA)) {\n                        continue\n                    }\n\n                    if (properties[key].includes(DATA_SCHEMA)) {\n                        path = 'r' + path\n                    }\n\n                    findPathsInSchema(getRefObjectOfSchema(tdSchema, properties[key]), path)\n                    return\n                } else {\n                    findPathsInSchema(properties[key], `${path}${key}/`)\n                    keys.add(key)\n                }\n            }\n        }\n\n        const additionalProperties = schema[ADDITONAL_PROPERTIES]\n        for (const key in additionalProperties) {\n            if (additionalProperties.hasOwnProperty(key)) {\n                if (key === REF) {\n                    if (path[0] === 'r' && additionalProperties[key].includes(DATA_SCHEMA)) {\n                        continue\n                    }\n\n                    if (additionalProperties[key].includes(DATA_SCHEMA)) {\n                        path = 'r' + path\n                    }\n\n                    findPathsInSchema(getRefObjectOfSchema(tdSchema, additionalProperties[key]), `${path}*/`)\n                    return\n                }\n            }\n        }\n\n        putKeysToPath(lookupTable, path, keys)\n    }\n\n    if (schema['type'] === 'array') {\n        const items = schema['items']\n\n        for (const item in items) {\n            if (items.hasOwnProperty(item)) {\n                if (item === REF) {\n                    if (path[0] === 'r' && items[item].includes(DATA_SCHEMA)) {\n                        continue\n                    }\n\n                    if (items[item].includes(DATA_SCHEMA)) {\n                        path = 'r' + path\n                    }\n\n                    findPathsInSchema(getRefObjectOfSchema(tdSchema, items[item]), path)\n                    return\n                }\n            }\n        }\n\n        putKeysToPath(lookupTable, path, keys)\n    }\n\n    for (const key in schema) {\n        if (schema.hasOwnProperty(key)) {\n            if (['allOf', 'oneOf', 'anyOf'].includes(key)) {\n                if (Array.isArray(schema[key])) {\n                    schema[key].forEach(element => {\n                        findPathsInSchema(element, path)\n                    })\n                }\n            }\n        }\n    }\n}\n\n/**\n * Stores the keys under a specific path\n * @param {Map} lookupTable The map that stores the paths in the schema\n * @param {string} path The path that is owner of the current keys\n * @param {Set} keys The set of keys that is going to be put\n */\nfunction putKeysToPath(lookupTable, path, keys) {\n    let pathKeys = lookupTable.get(path)\n\n    if (pathKeys) {\n        const union = new Set(pathKeys)\n        keys.forEach(k => {\n            union.add(k)\n        })\n\n        lookupTable.set(path, union)\n    } else {\n        lookupTable.set(path, keys)\n    }\n}\n\n/**\n * Gets the reference object in the schema\n * @param {object} schema The object that represent the schema\n * @param {string} ref The reference value in the schema\n * @returns The reference object the ref maps to\n */\nfunction getRefObjectOfSchema(schema, ref) {\n    const splitRef = ref.split('/')\n    if (splitRef[0] !== '#') {\n        console.log('Parsing not implemented for between files')\n        return\n    }\n\n    let result = schema\n\n    for (let i = 1; i < splitRef.length; i++) {\n        result = result[splitRef[i]]\n    }\n\n    return result\n}\n\n// Minimum similarity value to be able to say that two words are similar\nconst SIMILARITY_THRESHOLD = 0.85\n\n// Maximum value of length difference between two words\nconst MAX_LENGTH_DIFFERENCE = 2\n\n/**\n * Checks whether typo exists or not by comparing similarity of the two words\n * @param {string} actual The property name of the TD entered by user\n * @param {string} desired The desired property name that is retrieved from TD Schema\n * @returns Boolean value that tell whether typo exists or not\n */\nfunction doesTypoExist(actual, desired) {\n    if (Math.abs(actual.length - desired.length) > MAX_LENGTH_DIFFERENCE) {\n        return false\n    }\n\n    const similarity = calculateSimilarity(actual, desired)\n    return similarity > SIMILARITY_THRESHOLD && similarity !== 1.0\n}\n\n/**\n * Similarity of words calculated using Jaro-Winkler algorithm\n * @param {string} actual The property name of the TD entered by user\n * @param {string} desired The desired propert name that is retrieved from TD Schema\n * @returns Similarity of value the two inputs\n */\nfunction calculateSimilarity(actual, desired) {\n    let m = 0\n\n    if (actual.length === 0 || desired.length === 0) {\n        return 0\n    }\n\n    if (actual === desired) {\n        return 1\n    }\n\n    const range = Math.floor(Math.max(actual.length, desired.length) / 2) - 1\n    const actualMatches = new Array(actual.length)\n    const desiredMatches = new Array(desired.length)\n\n    // check lower and upper bounds to find the matches\n    for (let i = 0; i < actual.length; i++) {\n        const lowerBound = (i >= range) ? i - range : 0\n        const upperBound = (i + range <= desired.length) ? (i + range) : (desired.length - 1)\n\n        for (let j = lowerBound; j <= upperBound; j++) {\n            if (actualMatches[i] !== true && desiredMatches[j] !== true && actual[i] === desired[j]) {\n                m++\n                actualMatches[i] = desiredMatches[j] = true\n                break\n            }\n        }\n    }\n\n    if (m === 0) {\n        return 0\n    }\n\n    let k = 0\n    let transpositionCount = 0\n\n    // count transpositions\n    for (let i = 0; i < actual.length; i++) {\n        if (actualMatches[i] === true) {\n            let j = 0\n            for (j = k; j < desired.length; j++) {\n                if (desiredMatches[j] === true) {\n                    k = j + 1\n                    break\n                }\n            }\n\n            if (actual[i] !== desired[j]) {\n                transpositionCount++\n            }\n        }\n    }\n\n    let similarity = ((m / actual.length) + (m / desired.length) + ((m - (transpositionCount / 2)) / m)) / 3\n    let l = 0\n    const p = 0.1\n\n    // strengthen the similarity if the words start with same letters\n    if (similarity < 0.7) {\n        while (actual[l] === desired[l] && l < 4) {\n            l++\n        }\n\n        similarity = similarity + l * p * (1 - similarity)\n    }\n\n    return similarity\n}\n","import { tdValidator, tmValidator } from \"../external/TdPlayground\";\nimport { isThingModel } from \"../util\";\n\n// eslint-disable-next-line no-restricted-globals\nself.onmessage = async (message) => {\n  console.debug(\"validation worker received message...\");\n  let tdStr = message.data;\n\n  let td = {};\n  try {\n    td = JSON.parse(message.data);\n  } catch (e) {\n    console.debug(`ran into error while parsing TD: ${e}`);\n    postMessage(undefined);\n  }\n\n  try {\n    let result = undefined;\n    if (td && isThingModel(td)) {\n      result = await tmValidator(tdStr, console.debug, {});\n    } else {\n      result = await tdValidator(tdStr, console.debug, {});\n    }\n    postMessage(result);\n  } catch (e) {\n    postMessage(undefined);\n    console.debug(e);\n  }\n\n  console.debug(\"validation worker sent response...\");\n};\n","/********************************************************************************\n * Copyright (c) 2018 - 2020 Contributors to the Eclipse Foundation\n *\n * See the NOTICE file(s) distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License v. 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0, or the W3C Software Notice and\n *\n * SPDX-License-Identifier: EPL-2.0 OR W3C-20150513\n ********************************************************************************/\n\n/**\n * @param {Object} td\n * @returns {boolean}\n *\n * @description\n * isThingModel takes an object as argument and checks wether\n * it is a TD or a TM. If anything, but an object is passed,\n * the function will return false by default.\n */\nexport const isThingModel = (td) => {\n  if (!(typeof td === \"object\" && !Array.isArray(td) && td !== null)) {\n    return false;\n  }\n\n  if (!td.hasOwnProperty(\"@type\")) {\n    return false;\n  }\n\n  return td[\"@type\"].indexOf(\"tm:ThingModel\") > -1;\n};\n\n/**\n *\n * @param {*} firstAttribute\n * @param {*} object\n * @param {*} dontRender is a list of keys that shouldn't be packed into the attribute list.\n *\n * @description\n * Parses all key-value pairs of an object into an object'.\n *\n */\nexport const buildAttributeListObject = (\n  firstAttribute,\n  object,\n  dontRender\n) => {\n  let attributeListObject = { ...firstAttribute };\n\n  for (const [key, value] of Object.entries(object)) {\n    if (!dontRender.includes(key)) {\n      attributeListObject[key] = value;\n    }\n  }\n\n  return attributeListObject;\n};\n\n/**\n *\n * @param {*} forms\n *\n * @description\n * Converts Forms that have an array as the \"op\" value into multiple separate Forms\n * which only have a string as \"op\" value.\n */\nexport const separateForms = (forms) => {\n  if (forms === undefined && !forms) {\n    return [];\n  }\n\n  const newForms = [];\n\n  for (let i = 0; i < forms.length; i++) {\n    const form = forms[i];\n\n    if (!Array.isArray(form.op)) {\n      newForms.push(form);\n      continue;\n    }\n\n    for (let i = 0; i < form.op.length; i++) {\n      const temp = { ...form };\n      temp.op = form.op[i];\n      newForms.push(temp);\n    }\n  }\n\n  return newForms;\n};\n\n/**\n *\n * @param {itemToCheck} itemToCheck\n *\n * Checks if item contains Forms\n *\n */\nexport const hasForms = (itemToCheck) => {\n  return itemToCheck.forms ? true : false;\n};\n\n/**\n *Check if link exists in the links section of iteamToCheck\n */\nexport const hasLinks = (itemToCheck) => {\n  return itemToCheck.links ? true : false;\n};\n\n/**\n *Check if link exists in the links section of iteamToCheck\n */\nexport const checkIfLinkIsInItem = (link, itemToCheck) => {\n  for (const element of itemToCheck.links) {\n    if (element.href === link.href) {\n      return true;\n    }\n  }\n  return false;\n};\nexport const checkIfFormIsInItem = (form, itemToCheck) => {\n  for (const element of itemToCheck.forms) {\n    if (typeof form.op === \"string\") {\n      return checkIfFormIsInElement(form, element);\n    } else {\n      for (const x of form.op) {\n        if (typeof element.op === \"string\") {\n          if (element.op === x) {\n            return true;\n          }\n        } else {\n          if (element.op.includes(x)) {\n            let deepCompare = true;\n            for (const y in form) {\n              if (y !== \"op\") {\n                if (element[y] !== form[y]) {\n                  deepCompare = false;\n                }\n              }\n            }\n            if (deepCompare) return true;\n          }\n        }\n      }\n    }\n  }\n  return false;\n};\n\nconst checkIfFormIsInElement = (form, element) => {\n  if (typeof element.op === \"string\") {\n    if (element.op === form.op) {\n      return true;\n    }\n  } else {\n    if (element.op.includes(form.op)) {\n      let deepCompare = true;\n      for (const y in form) {\n        if (y !== \"op\") {\n          if (element[y] !== form[y]) {\n            deepCompare = false;\n          }\n        }\n      }\n      if (deepCompare) return true;\n    }\n  }\n};\n\n/**\n * Display the selected Thing description\n * Save the current Thing Description if wanted\n * Method supports both fileHandler and jsonld file\n */\nexport const changeBetweenTd = async (context, href) => {\n  var writable;\n  if (context.linkedTd[href][\"kind\"] === \"file\") {\n    try {\n      if (context.isModified && context.fileHandle) {\n        writable = await context.fileHandle.createWritable();\n        await writable.write(context.offlineTD);\n        await writable.close();\n      }\n    } catch (e) {\n      console.error(e.message);\n    }\n    let fileHandle = context.linkedTd[href];\n    const file = await fileHandle.getFile();\n    const td = JSON.parse(await file.text());\n    let offlineTd = JSON.stringify(td, null, 2);\n    context.setFileHandle(fileHandle);\n    context.updateOfflineTD(offlineTd);\n    context.updateIsModified(false);\n    document.getElementById(\"linkedTd\").value = href;\n  }\n  // If we create a TD using the New button then we don't have a file handler\n  // In that case the entry in linkedTd is not a file handler but a Thing Description Json\n  else if (Object.keys(context.linkedTd[href]).length) {\n    try {\n      if (context.isModified && context.fileHandle) {\n        writable = await context.fileHandle.createWritable();\n        await writable.write(context.offlineTD);\n        await writable.close();\n      }\n    } catch (e) {\n      console.error(e.message);\n    }\n    context.setFileHandle(undefined);\n    const td = context.linkedTd[href];\n    let offlineTd = JSON.stringify(td, null, 2);\n    context.updateOfflineTD(offlineTd);\n    context.updateIsModified(false);\n    document.getElementById(\"linkedTd\").value = href;\n  }\n};\n\n/**\n * @param {*} source Source object\n * @param {string} key Source key\n * @param {*} atContext Respective @context value\n *\n * @returns {string} String value of source[key] with prepended LRI or RLI symbol\n *\n * @description\n * Returns the value of source[key] with the direction information (rtl/ltr).\n */\nexport const getDirectedValue = (source, key, atContext) => {\n  // if there is no value to be directed this function returns\n  // to prevent any further call on undefined errors.\n  if (!source[key]) {\n    return \"\";\n  }\n\n  const LRI = \"\\u2066\";\n  const RLI = \"\\u2067\";\n  const TABLE = {\n    ar: \"rtl\",\n    fa: \"rtl\",\n    ps: \"rtl\",\n    ur: \"rtl\",\n    hy: \"ltr\",\n    as: \"ltr\",\n    bn: \"ltr\",\n    zb: \"ltr\",\n    ab: \"ltr\",\n    be: \"ltr\",\n    bg: \"ltr\",\n    kk: \"ltr\",\n    mk: \"ltr\",\n    ru: \"ltr\",\n    uk: \"ltr\",\n    hi: \"ltr\",\n    mr: \"ltr\",\n    ne: \"ltr\",\n    ko: \"ltr\",\n    ma: \"ltr\",\n    am: \"ltr\",\n    ti: \"ltr\",\n    ka: \"ltr\",\n    el: \"ltr\",\n    gu: \"ltr\",\n    pa: \"ltr\",\n    he: \"rtl\",\n    iw: \"rtl\",\n    yi: \"rtl\",\n    ja: \"ltr\",\n    km: \"ltr\",\n    kn: \"ltr\",\n    lo: \"ltr\",\n    af: \"ltr\",\n    ay: \"ltr\",\n    bs: \"ltr\",\n    ca: \"ltr\",\n    ch: \"ltr\",\n    cs: \"ltr\",\n    cy: \"ltr\",\n    da: \"ltr\",\n    de: \"ltr\",\n    en: \"ltr\",\n    eo: \"ltr\",\n    es: \"ltr\",\n    et: \"ltr\",\n    eu: \"ltr\",\n    fi: \"ltr\",\n    fj: \"ltr\",\n    fo: \"ltr\",\n    fr: \"ltr\",\n    fy: \"ltr\",\n    ga: \"ltr\",\n    gl: \"ltr\",\n    gn: \"ltr\",\n    gv: \"ltr\",\n    hr: \"ltr\",\n    ht: \"ltr\",\n    hu: \"ltr\",\n    id: \"ltr\",\n    in: \"ltr\",\n    is: \"ltr\",\n    it: \"ltr\",\n    kl: \"ltr\",\n    la: \"ltr\",\n    lb: \"ltr\",\n    ln: \"ltr\",\n    lt: \"ltr\",\n    lv: \"ltr\",\n    mg: \"ltr\",\n    mh: \"ltr\",\n    mo: \"ltr\",\n    ms: \"ltr\",\n    mt: \"ltr\",\n    na: \"ltr\",\n    nb: \"ltr\",\n    nd: \"ltr\",\n    nl: \"ltr\",\n    nn: \"ltr\",\n    no: \"ltr\",\n    nr: \"ltr\",\n    ny: \"ltr\",\n    om: \"ltr\",\n    pl: \"ltr\",\n    pt: \"ltr\",\n    qu: \"ltr\",\n    rm: \"ltr\",\n    rn: \"ltr\",\n    ro: \"ltr\",\n    rw: \"ltr\",\n    sg: \"ltr\",\n    sk: \"ltr\",\n    sl: \"ltr\",\n    sm: \"ltr\",\n    so: \"ltr\",\n    sq: \"ltr\",\n    ss: \"ltr\",\n    st: \"ltr\",\n    sv: \"ltr\",\n    sw: \"ltr\",\n    tl: \"ltr\",\n    tn: \"ltr\",\n    to: \"ltr\",\n    tr: \"ltr\",\n    ts: \"ltr\",\n    ve: \"ltr\",\n    vi: \"ltr\",\n    xh: \"ltr\",\n    zu: \"ltr\",\n    ds: \"ltr\",\n    gs: \"ltr\",\n    hs: \"ltr\",\n    me: \"ltr\",\n    ni: \"ltr\",\n    ns: \"ltr\",\n    te: \"ltr\",\n    tk: \"ltr\",\n    tm: \"ltr\",\n    tp: \"ltr\",\n    tv: \"ltr\",\n    ml: \"ltr\",\n    my: \"ltr\",\n    nq: \"ltr\",\n    or: \"ltr\",\n    si: \"ltr\",\n    ta: \"ltr\",\n    dv: \"rtl\",\n    th: \"ltr\",\n    dz: \"ltr\",\n  };\n\n  const getDirectionSymbol = (dir) => (dir === \"ltr\" ? LRI : RLI);\n\n  // title, description and language tags (like \"en\" or \"en-US\") are treated differently\n  if (\n    ![\"title\", \"description\"].includes(key) &&\n    !/^[A-Za-z]{2}(-[A-Za-z]{2})?$/.test(key)\n  ) {\n    return (\n      getDirectionSymbol(source[key].toString().getDirection()) + source[key]\n    );\n  }\n\n  if (/^[A-Za-z]{2}(-[A-Za-z]{2})?$/.test(key)) {\n    // Language tags can be compound like ar-EG or en-US, split when needed\n    // Also, we ignore the case for language tags\n    const lookupKey = key.includes(\"-\") ? key.split(\"-\")[0] : key.toLowerCase();\n    const dir = TABLE[lookupKey];\n    if (dir) return getDirectionSymbol(dir) + source[key];\n    return getDirectionSymbol(\"ltr\") + source[key];\n  }\n\n  let direction;\n  let lang;\n\n  if (!Array.isArray(atContext)) {\n    atContext = [atContext];\n  }\n\n  atContext.forEach((e) => {\n    if (typeof e === \"object\") {\n      if (e[\"@direction\"]) direction = e[\"@direction\"];\n      if (e[\"@language\"]) lang = e[\"@language\"];\n    }\n  });\n\n  if (key === \"title\" || key === \"description\") {\n    if (direction) return getDirectionSymbol(direction) + source[key];\n    if (lang) {\n      const lookupKey = lang.includes(\"-\")\n        ? lang.split(\"-\")[0]\n        : lang.toLowerCase();\n      const dir = TABLE[lookupKey];\n      if (dir) return getDirectionSymbol(dir) + source[key];\n      return getDirectionSymbol(\"ltr\") + source[key];\n    }\n  }\n\n  return (\n    getDirectionSymbol(source[key].toString().getDirection()) + source[key]\n  );\n};\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = () => {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [895], () => (__webpack_require__(7705)))\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","var deferred = [];\n__webpack_require__.O = (result, chunkIds, fn, priority) => {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar chunkIds = deferred[i][0];\n\t\tvar fn = deferred[i][1];\n\t\tvar priority = deferred[i][2];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = (chunkId) => {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"static/js/\" + chunkId + \".\" + \"c451f37f\" + \".chunk.js\";\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.miniCssF = (chunkId) => {\n\t// return url for filenames based on template\n\treturn undefined;\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","__webpack_require__.p = \"/editdor/\";","// no baseURI\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t917: 1\n};\n\n// importScripts chunk loading\nvar installChunk = (data) => {\n\tvar chunkIds = data[0];\n\tvar moreModules = data[1];\n\tvar runtime = data[2];\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = (chunkId, promises) => {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunkeditdor\"] = self[\"webpackChunkeditdor\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","var next = __webpack_require__.x;\n__webpack_require__.x = () => {\n\treturn __webpack_require__.e(895).then(next);\n};","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n"],"names":["bcp47pattern","resolvePath","object","path","defaultValue","split","filter","p","reduce","o","checkPropUniqueness","tdString","results","jsonValidator","td","JSON","parse","hasOwnProperty","push","error","errorString","toString","startQuote","indexOf","restString","slice","endQuote","interactionName","properties","replace","actions","events","securityContains","parent","child","every","elem","checkMultiLangConsistency","multiLang","isTdTitlesDescriptions","rootTitlesObject","titles","rootTitles","Object","keys","isStringObjectKeyValue","title","rootDescriptionsObject","descriptions","rootDescriptions","description","tdProperties","i","length","curPropertyName","curProperty","titlesKeys","descriptionsKeys","tdActions","curActionName","curAction","tdEvents","curEventName","curEvent","myArray","stringify","arrayArraysItemsEqual","flatArray","index","arrayElement","e","stringElement","isBCP47","element","test","checkBCP47array","elementName","searchedString","searchedObject","objKeys","checkLinksRelTypeCount","typeCount","links","rel","tdValidator","logFunc","_ref","checkDefaults","checkJsonLd","Promise","res","rej","undefined","report","json","schema","defaults","jsonld","additional","details","enumConst","propItems","security","propUniqueness","multiLangConsistency","linksRelTypeCount","readWriteOnly","uriVariableSecurity","detailComments","validationErrors","tdJson","err","message","ajv","Ajv","strict","apply","addSchema","tdSchema","validate","fullTdSchema","errorsText","filterErrorMessages","errors","curInput","input","curOutput","output","checkEnumConst","type","checkPropItems","readOnly","writeOnly","formElIndex","forms","formEl","op","some","el","observable","checkReadWriteOnly","evalAssertion","securityDefinitionsObject","securityDefinitions","curForms","j","curForm","checkSecurity","checkSecPropUniqueness","securityDefinitionsNames","securityUriVariables","curSecurityDefinition","scheme","in","name","uriVariablesResult","uriVariablesDistinctResult","rootUriVariables","uriVariables","curHref","href","v","includes","curPropertyUriVariables","value","curActionUriVariables","curEventUriVariables","checkUriSecurity","forEach","prop","tdStr","result","securitySchemeName","out","resultobj","Status","ID","Comment","ce","dataPath","format","then","nquads","tmValidator","tmString","_ref2","tmOptionalPointer","tmJson","addFormats","tmSchema","tmStr","tm","tmProperties","tmActions","tmEvents","substring","pathTarget","checkTmOptionalPointer","REF","PROPERTIES","ADDITONAL_PROPERTIES","DATA_SCHEMA","jsonSchema","lookupTable","Map","filteredLookupTable","findPathsInSchema","key","size","pathDepth","match","pathDepthMap","get","set","createSchemaLookupTable","Set","getRefObjectOfSchema","concat","add","additionalProperties","putKeysToPath","items","item","Array","isArray","pathKeys","union","k","ref","splitRef","console","log","self","onmessage","async","debug","data","postMessage","isThingModel","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__","call","m","x","__webpack_exports__","O","deferred","chunkIds","fn","priority","notFulfilled","Infinity","fulfilled","splice","r","n","getter","__esModule","d","a","definition","defineProperty","enumerable","f","chunkId","all","promises","u","miniCssF","g","globalThis","this","Function","window","obj","prototype","Symbol","toStringTag","installedChunks","importScripts","chunkLoadingGlobal","parentChunkLoadingFunction","bind","moreModules","runtime","pop","next"],"sourceRoot":""}