{"version":3,"file":"static/js/347.b6e869d8.chunk.js","mappings":"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","sources":["workers/workerFunctions.js","util.js","workers/schemaWorker.js"],"sourcesContent":["/********************************************************************************\n * Copyright (c) 2018 - 2024 Contributors to the Eclipse Foundation\n *\n * See the NOTICE file(s) distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License v. 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0, or the W3C Software Notice and\n *\n * SPDX-License-Identifier: EPL-2.0 OR W3C-20150513\n ********************************************************************************/\n// Caches the fetched schemas and is used for future requests to the same schema address.\nlet schemaCache = new Map();\n\nconst modbusSchemaUri =\n  \"https://w3c.github.io/wot-binding-templates/bindings/protocols/modbus/modbus.schema.json\";\nconst coapSchemaUri =\n  \"https://w3c.github.io/wot-binding-templates/bindings/protocols/coap/coap.schema.json\";\nconst httpSchemaUri =\n  \"https://w3c.github.io/wot-binding-templates/bindings/protocols/http/http.schema.json\";\nconst mqttSchemaUri =\n  \"https://w3c.github.io/wot-binding-templates/bindings/protocols/mqtt/mqtt.schema.json\";\n\nlet schemaUriMap = undefined;\n\nexport {\n  extractSchemaUrisFromContext,\n  extractSchemaUriFromBase,\n  fetchSchemas,\n  updateSchemaCache,\n};\n\n/**\n * Initializes the map that contains information about all supported schemas.\n */\nfunction initializeSchemaUriMap() {\n  const tmpSchemaUriMap = new Map();\n  tmpSchemaUriMap.set(\"modbus\", modbusSchemaUri);\n  tmpSchemaUriMap.set(\"modbus+tcp\", modbusSchemaUri);\n  tmpSchemaUriMap.set(\"modbus+udp\", modbusSchemaUri);\n\n  tmpSchemaUriMap.set(\"coap\", coapSchemaUri);\n  tmpSchemaUriMap.set(\"coap+tcp\", coapSchemaUri);\n  tmpSchemaUriMap.set(\"coap+ws\", coapSchemaUri);\n  tmpSchemaUriMap.set(\"coaps\", coapSchemaUri);\n  tmpSchemaUriMap.set(\"coaps+tcp\", coapSchemaUri);\n  tmpSchemaUriMap.set(\"coaps+ws\", coapSchemaUri);\n\n  tmpSchemaUriMap.set(\"http\", httpSchemaUri);\n  tmpSchemaUriMap.set(\"https\", httpSchemaUri);\n\n  tmpSchemaUriMap.set(\"mqtt\", mqttSchemaUri);\n  tmpSchemaUriMap.set(\"mqtt+tcp\", mqttSchemaUri);\n  tmpSchemaUriMap.set(\"mqtt+ssl\", mqttSchemaUri);\n  tmpSchemaUriMap.set(\"mqtt+ws\", mqttSchemaUri);\n\n  schemaUriMap = tmpSchemaUriMap;\n}\n\n/**\n * Extracts the schemas from a WoT context.\n * Example that can be parsed by this function:\n * 1:\n *      \"http://www.example.com\"\n * 2:\n *      [\n *           \"http://www.example1.com\",\n *           \"http://www.example2.com\",\n *           \"http://www.example3.com\",\n *           {\n *               \"a\": \"http://www.exampleA.com\",\n *               \"b\": \"http://www.exampleB.com\",\n *           },\n *           {\n *               \"c\": \"http://www.exampleA.com\"\n *           }\n *      ]\n *\n * Any part of the second example object can be removed and the function will still\n * be able to parse it. Also any elements that are not in the format stated above\n * will be ignored. This function is following the WoT @context definition.\n * @param {String | Array<String>} context\n * @returns {Array<String>}\n */\nfunction extractSchemaUrisFromContext(context) {\n  if (!context) {\n    return [];\n  }\n\n  let contextType = typeof context;\n  if (contextType !== \"string\" && context.constructor !== Array) {\n    return [];\n  }\n\n  if (contextType === \"string\") {\n    return [context];\n  }\n\n  // context is an array\n  let schemaUris = [];\n  for (let i = 0; i < context.length; i++) {\n    let schema = context[i];\n\n    // schema is neither an object nor a string\n    if (\n      !(\n        typeof schema === \"object\" &&\n        !Array.isArray(schema) &&\n        schema !== null\n      ) &&\n      typeof schema !== \"string\"\n    ) {\n      continue;\n    }\n\n    if (typeof schema === \"string\") {\n      schemaUris.push(schema);\n      continue;\n    }\n\n    // schema is object\n    for (const ontologyName in schema) {\n      if (!schema.hasOwnProperty(ontologyName)) {\n        continue;\n      }\n\n      let schemaUri = schema[ontologyName];\n      if (typeof schemaUri !== \"string\") {\n        continue;\n      }\n\n      schemaUris.push(schemaUri);\n    }\n  }\n\n  return schemaUris;\n}\n\n/**\n * Parses the base attribute of a TD/TM, retrieves the protocol used and returns\n * a link to the according json schema document if known.\n * @param {Object} td\n * @returns {Array<String>}\n */\nfunction extractSchemaUriFromBase(td) {\n  if (!td.hasOwnProperty(\"base\")) {\n    return [];\n  }\n\n  let base = td[\"base\"];\n  let parsedBaseUrl;\n\n  try {\n    parsedBaseUrl = new URL(base);\n  } catch (e) {\n    console.error(`base url is invalid: ${e}`);\n    return [];\n  }\n\n  if (schemaUriMap === undefined) {\n    initializeSchemaUriMap();\n  }\n\n  let schema = parsedBaseUrl.protocol.substring(\n    0,\n    parsedBaseUrl.protocol.length - 1\n  );\n  console.debug(`cheking binding schema map for ${schema}...`);\n  let schemaUri = schemaUriMap.get(schema);\n\n  return !schemaUri ? [] : [schemaUri];\n}\n\n/**\n * Fetch schemas checks if a certain schema was already fetched and tries to retrieve it\n * from an in memory cache. If the cache has no entry for a schema it will be fetched.\n * @param {Array<String>} schemaUris\n * @returns {Map<String, Object>} A map that maps from schema URI to a JSON schema obejct or undefined\n * if an error occured while fetching.\n */\nasync function fetchSchemas(schemaUris) {\n  let schemaMap = new Map();\n\n  for (let i = 0; i < schemaUris.length; i++) {\n    let schemaUriStr = schemaUris[i];\n\n    // check if schema is already in cache\n    let cachedSchema = schemaCache.get(schemaUriStr);\n    if (cachedSchema !== undefined) {\n      console.debug(`using cached schema for ${schemaUriStr}`);\n      schemaMap.set(schemaUriStr, cachedSchema);\n      continue;\n    }\n\n    // fetch schema from external resource\n    try {\n      const schemaUri = new URL(schemaUriStr);\n      const res = await fetch(schemaUri);\n      const schema = await res.json();\n\n      schemaMap.set(schemaUriStr, schema);\n    } catch (e) {\n      console.error(e);\n      schemaMap.set(schemaUriStr, undefined);\n    }\n  }\n\n  return schemaMap;\n}\n\n/**\n * Updates the schema cache with a schema map.\n * @param {Map<String, Object>} schemaMap\n */\nfunction updateSchemaCache(schemaMap) {\n  schemaMap.forEach(function (schema, schemaUri) {\n    if (schema !== undefined) {\n      schemaCache.set(schemaUri, schema);\n    }\n  });\n}\n","/********************************************************************************\n * Copyright (c) 2018 - 2020 Contributors to the Eclipse Foundation\n *\n * See the NOTICE file(s) distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License v. 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0, or the W3C Software Notice and\n *\n * SPDX-License-Identifier: EPL-2.0 OR W3C-20150513\n ********************************************************************************/\n\n/**\n * @param {Object} td\n * @returns {boolean}\n *\n * @description\n * isThingModel takes an object as argument and checks wether\n * it is a TD or a TM. If anything, but an object is passed,\n * the function will return false by default.\n */\nexport const isThingModel = (td) => {\n  if (!(typeof td === \"object\" && !Array.isArray(td) && td !== null)) {\n    return false;\n  }\n\n  if (!td.hasOwnProperty(\"@type\")) {\n    return false;\n  }\n\n  return td[\"@type\"].indexOf(\"tm:ThingModel\") > -1;\n};\n\n/**\n *\n * @param {*} firstAttribute\n * @param {*} object\n * @param {*} dontRender is a list of keys that shouldn't be packed into the attribute list.\n *\n * @description\n * Parses all key-value pairs of an object into an object'.\n *\n */\nexport const buildAttributeListObject = (\n  firstAttribute,\n  object,\n  dontRender\n) => {\n  let attributeListObject = { ...firstAttribute };\n\n  for (const [key, value] of Object.entries(object)) {\n    if (!dontRender.includes(key)) {\n      attributeListObject[key] = value;\n    }\n  }\n\n  return attributeListObject;\n};\n\n/**\n *\n * @param {*} forms\n *\n * @description\n * Converts Forms that have an array as the \"op\" value into multiple separate Forms\n * which only have a string as \"op\" value.\n */\nexport const separateForms = (forms) => {\n  if (forms === undefined && !forms) {\n    return [];\n  }\n\n  const newForms = [];\n\n  for (let i = 0; i < forms.length; i++) {\n    const form = forms[i];\n\n    if (!Array.isArray(form.op)) {\n      newForms.push(form);\n      continue;\n    }\n\n    for (let i = 0; i < form.op.length; i++) {\n      const temp = { ...form };\n      temp.op = form.op[i];\n      newForms.push(temp);\n    }\n  }\n\n  return newForms;\n};\n\n/**\n *\n * @param {itemToCheck} itemToCheck\n *\n * Checks if item contains Forms\n *\n */\nexport const hasForms = (itemToCheck) => {\n  return itemToCheck.forms ? true : false;\n};\n\n/**\n *Check if link exists in the links section of iteamToCheck\n */\nexport const hasLinks = (itemToCheck) => {\n  return itemToCheck.links ? true : false;\n};\n\n/**\n *Check if link exists in the links section of iteamToCheck\n */\nexport const checkIfLinkIsInItem = (link, itemToCheck) => {\n  for (const element of itemToCheck.links) {\n    if (element.href === link.href) {\n      return true;\n    }\n  }\n  return false;\n};\nexport const checkIfFormIsInItem = (form, itemToCheck) => {\n  for (const element of itemToCheck.forms) {\n    if (typeof form.op === \"string\") {\n      return checkIfFormIsInElement(form, element);\n    } else {\n      for (const x of form.op) {\n        if (typeof element.op === \"string\") {\n          if (element.op === x) {\n            return true;\n          }\n        } else {\n          if (element.op.includes(x)) {\n            let deepCompare = true;\n            for (const y in form) {\n              if (y !== \"op\") {\n                if (element[y] !== form[y]) {\n                  deepCompare = false;\n                }\n              }\n            }\n            if (deepCompare) return true;\n          }\n        }\n      }\n    }\n  }\n  return false;\n};\n\nconst checkIfFormIsInElement = (form, element) => {\n  if (typeof element.op === \"string\") {\n    if (element.op === form.op) {\n      return true;\n    }\n  } else {\n    if (element.op.includes(form.op)) {\n      let deepCompare = true;\n      for (const y in form) {\n        if (y !== \"op\") {\n          if (element[y] !== form[y]) {\n            deepCompare = false;\n          }\n        }\n      }\n      if (deepCompare) return true;\n    }\n  }\n};\n\n/**\n * Display the selected Thing description\n * Save the current Thing Description if wanted\n * Method supports both fileHandler and jsonld file\n */\nexport const changeBetweenTd = async (context, href) => {\n  var writable;\n  if (context.linkedTd[href][\"kind\"] === \"file\") {\n    try {\n      if (context.isModified && context.fileHandle) {\n        writable = await context.fileHandle.createWritable();\n        await writable.write(context.offlineTD);\n        await writable.close();\n      }\n    } catch (e) {\n      console.error(e.message);\n    }\n    let fileHandle = context.linkedTd[href];\n    const file = await fileHandle.getFile();\n    const td = JSON.parse(await file.text());\n    let offlineTd = JSON.stringify(td, null, 2);\n    context.setFileHandle(fileHandle);\n    context.updateOfflineTD(offlineTd);\n    context.updateIsModified(false);\n    document.getElementById(\"linkedTd\").value = href;\n  }\n  // If we create a TD using the New button then we don't have a file handler\n  // In that case the entry in linkedTd is not a file handler but a Thing Description Json\n  else if (Object.keys(context.linkedTd[href]).length) {\n    try {\n      if (context.isModified && context.fileHandle) {\n        writable = await context.fileHandle.createWritable();\n        await writable.write(context.offlineTD);\n        await writable.close();\n      }\n    } catch (e) {\n      console.error(e.message);\n    }\n    context.setFileHandle(undefined);\n    const td = context.linkedTd[href];\n    let offlineTd = JSON.stringify(td, null, 2);\n    context.updateOfflineTD(offlineTd);\n    context.updateIsModified(false);\n    document.getElementById(\"linkedTd\").value = href;\n  }\n};\n\n/**\n * @param {*} source Source object\n * @param {string} key Source key\n * @param {*} atContext Respective @context value\n *\n * @returns {string} String value of source[key] with prepended LRI or RLI symbol\n *\n * @description\n * Returns the value of source[key] with the direction information (rtl/ltr).\n */\nexport const getDirectedValue = (source, key, atContext) => {\n  // if there is no value to be directed this function returns\n  // to prevent any further call on undefined errors.\n  if (!source[key]) {\n    return \"\";\n  }\n\n  const LRI = \"\\u2066\";\n  const RLI = \"\\u2067\";\n  const TABLE = {\n    ar: \"rtl\",\n    fa: \"rtl\",\n    ps: \"rtl\",\n    ur: \"rtl\",\n    hy: \"ltr\",\n    as: \"ltr\",\n    bn: \"ltr\",\n    zb: \"ltr\",\n    ab: \"ltr\",\n    be: \"ltr\",\n    bg: \"ltr\",\n    kk: \"ltr\",\n    mk: \"ltr\",\n    ru: \"ltr\",\n    uk: \"ltr\",\n    hi: \"ltr\",\n    mr: \"ltr\",\n    ne: \"ltr\",\n    ko: \"ltr\",\n    ma: \"ltr\",\n    am: \"ltr\",\n    ti: \"ltr\",\n    ka: \"ltr\",\n    el: \"ltr\",\n    gu: \"ltr\",\n    pa: \"ltr\",\n    he: \"rtl\",\n    iw: \"rtl\",\n    yi: \"rtl\",\n    ja: \"ltr\",\n    km: \"ltr\",\n    kn: \"ltr\",\n    lo: \"ltr\",\n    af: \"ltr\",\n    ay: \"ltr\",\n    bs: \"ltr\",\n    ca: \"ltr\",\n    ch: \"ltr\",\n    cs: \"ltr\",\n    cy: \"ltr\",\n    da: \"ltr\",\n    de: \"ltr\",\n    en: \"ltr\",\n    eo: \"ltr\",\n    es: \"ltr\",\n    et: \"ltr\",\n    eu: \"ltr\",\n    fi: \"ltr\",\n    fj: \"ltr\",\n    fo: \"ltr\",\n    fr: \"ltr\",\n    fy: \"ltr\",\n    ga: \"ltr\",\n    gl: \"ltr\",\n    gn: \"ltr\",\n    gv: \"ltr\",\n    hr: \"ltr\",\n    ht: \"ltr\",\n    hu: \"ltr\",\n    id: \"ltr\",\n    in: \"ltr\",\n    is: \"ltr\",\n    it: \"ltr\",\n    kl: \"ltr\",\n    la: \"ltr\",\n    lb: \"ltr\",\n    ln: \"ltr\",\n    lt: \"ltr\",\n    lv: \"ltr\",\n    mg: \"ltr\",\n    mh: \"ltr\",\n    mo: \"ltr\",\n    ms: \"ltr\",\n    mt: \"ltr\",\n    na: \"ltr\",\n    nb: \"ltr\",\n    nd: \"ltr\",\n    nl: \"ltr\",\n    nn: \"ltr\",\n    no: \"ltr\",\n    nr: \"ltr\",\n    ny: \"ltr\",\n    om: \"ltr\",\n    pl: \"ltr\",\n    pt: \"ltr\",\n    qu: \"ltr\",\n    rm: \"ltr\",\n    rn: \"ltr\",\n    ro: \"ltr\",\n    rw: \"ltr\",\n    sg: \"ltr\",\n    sk: \"ltr\",\n    sl: \"ltr\",\n    sm: \"ltr\",\n    so: \"ltr\",\n    sq: \"ltr\",\n    ss: \"ltr\",\n    st: \"ltr\",\n    sv: \"ltr\",\n    sw: \"ltr\",\n    tl: \"ltr\",\n    tn: \"ltr\",\n    to: \"ltr\",\n    tr: \"ltr\",\n    ts: \"ltr\",\n    ve: \"ltr\",\n    vi: \"ltr\",\n    xh: \"ltr\",\n    zu: \"ltr\",\n    ds: \"ltr\",\n    gs: \"ltr\",\n    hs: \"ltr\",\n    me: \"ltr\",\n    ni: \"ltr\",\n    ns: \"ltr\",\n    te: \"ltr\",\n    tk: \"ltr\",\n    tm: \"ltr\",\n    tp: \"ltr\",\n    tv: \"ltr\",\n    ml: \"ltr\",\n    my: \"ltr\",\n    nq: \"ltr\",\n    or: \"ltr\",\n    si: \"ltr\",\n    ta: \"ltr\",\n    dv: \"rtl\",\n    th: \"ltr\",\n    dz: \"ltr\",\n  };\n\n  const getDirectionSymbol = (dir) => (dir === \"ltr\" ? LRI : RLI);\n\n  // title, description and language tags (like \"en\" or \"en-US\") are treated differently\n  if (\n    ![\"title\", \"description\"].includes(key) &&\n    !/^[A-Za-z]{2}(-[A-Za-z]{2})?$/.test(key)\n  ) {\n    return (\n      getDirectionSymbol(source[key].toString().getDirection()) + source[key]\n    );\n  }\n\n  if (/^[A-Za-z]{2}(-[A-Za-z]{2})?$/.test(key)) {\n    // Language tags can be compound like ar-EG or en-US, split when needed\n    // Also, we ignore the case for language tags\n    const lookupKey = key.includes(\"-\") ? key.split(\"-\")[0] : key.toLowerCase();\n    const dir = TABLE[lookupKey];\n    if (dir) return getDirectionSymbol(dir) + source[key];\n    return getDirectionSymbol(\"ltr\") + source[key];\n  }\n\n  let direction;\n  let lang;\n\n  if (!Array.isArray(atContext)) {\n    atContext = [atContext];\n  }\n\n  atContext.forEach((e) => {\n    if (typeof e === \"object\") {\n      if (e[\"@direction\"]) direction = e[\"@direction\"];\n      if (e[\"@language\"]) lang = e[\"@language\"];\n    }\n  });\n\n  if (key === \"title\" || key === \"description\") {\n    if (direction) return getDirectionSymbol(direction) + source[key];\n    if (lang) {\n      const lookupKey = lang.includes(\"-\")\n        ? lang.split(\"-\")[0]\n        : lang.toLowerCase();\n      const dir = TABLE[lookupKey];\n      if (dir) return getDirectionSymbol(dir) + source[key];\n      return getDirectionSymbol(\"ltr\") + source[key];\n    }\n  }\n\n  return (\n    getDirectionSymbol(source[key].toString().getDirection()) + source[key]\n  );\n};\n","import {\n  extractSchemaUrisFromContext,\n  extractSchemaUriFromBase,\n  fetchSchemas,\n  updateSchemaCache,\n} from \"./workerFunctions\";\n\nimport { isThingModel } from \"../util\";\n\n// If the JSON sent to the worker is faulty it returns the last valid schema map.\nlet lastSentSchemaMap = new Map();\n\nconst tdSchema =\n  \"https://raw.githubusercontent.com/thingweb/thingweb-playground/%40thing-description-playground/web%401.0.0/packages/playground-core/td-schema.json\";\nconst tmSchema =\n  \"https://raw.githubusercontent.com/w3c/wot-thing-description/main/validation/tm-json-schema-validation.json\";\n\n// eslint-disable-next-line no-restricted-globals\nself.onmessage = async (message) => {\n  // Check that prevents messages sent from webpack and react scripts to be executed.\n  // Not sure why this is happening at the moment. This is only a \"quick\" fix.\n  if (!(typeof message.data === \"string\" || message.data instanceof String)) {\n    return;\n  }\n\n  let td = {};\n  try {\n    td = JSON.parse(message.data);\n  } catch (e) {\n    console.debug(`ran into error while parsing TD: ${e}`);\n    postMessage(lastSentSchemaMap);\n    return;\n  }\n\n  if (typeof td !== \"object\" || td.constructor === Array || !td) {\n    return;\n  }\n\n  let basicSchema = !isThingModel(td) ? tdSchema : tmSchema;\n  let contextSchemaUris = extractSchemaUrisFromContext(td[\"@context\"]);\n  let baseSchemaUris = extractSchemaUriFromBase(td);\n\n  let newSchemas = [basicSchema, ...contextSchemaUris, ...baseSchemaUris];\n  if (isThingModel) {\n    newSchemas = newSchemas.filter(\n      (schema) => schema !== \"https://www.w3.org/2019/wot/td/v1\"\n    );\n  }\n\n  let schemaMap = await fetchSchemas(newSchemas);\n  updateSchemaCache(schemaMap);\n\n  lastSentSchemaMap = schemaMap;\n  postMessage(schemaMap);\n  console.debug(\"schema worker sent response...\");\n};\n"],"names":["schemaCache","Map","modbusSchemaUri","coapSchemaUri","httpSchemaUri","mqttSchemaUri","schemaUriMap","extractSchemaUriFromBase","td","hasOwnProperty","parsedBaseUrl","base","URL","e","console","error","concat","undefined","tmpSchemaUriMap","set","initializeSchemaUriMap","schema","protocol","substring","length","debug","schemaUri","get","isThingModel","Array","isArray","indexOf","lastSentSchemaMap","self","onmessage","async","message","data","String","JSON","parse","postMessage","constructor","newSchemas","context","contextType","schemaUris","i","ontologyName","push","extractSchemaUrisFromContext","filter","schemaMap","schemaUriStr","cachedSchema","res","fetch","json","fetchSchemas","forEach","updateSchemaCache"],"sourceRoot":""}